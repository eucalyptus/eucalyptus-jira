diff --git a/clc/modules/cluster-manager/src/main/java/com/eucalyptus/network/EdgeNetworkingService.groovy b/clc/modules/cluster-manager/src/main/java/com/eucalyptus/network/EdgeNetworkingService.groovy
index fc5971b..e15cc10 100644
--- a/clc/modules/cluster-manager/src/main/java/com/eucalyptus/network/EdgeNetworkingService.groovy
+++ b/clc/modules/cluster-manager/src/main/java/com/eucalyptus/network/EdgeNetworkingService.groovy
@@ -20,7 +20,10 @@
 package com.eucalyptus.network
 
 import com.eucalyptus.address.Addresses
+import com.eucalyptus.cloud.ResourceToken
+import com.eucalyptus.cloud.VmInstanceLifecycleHelpers
 import com.eucalyptus.cloud.util.NotEnoughResourcesException
+import com.eucalyptus.cluster.Clusters
 import com.eucalyptus.compute.common.network.DescribeNetworkingFeaturesResponseType
 import com.eucalyptus.compute.common.network.DescribeNetworkingFeaturesResult
 import com.eucalyptus.compute.common.network.DescribeNetworkingFeaturesType
@@ -43,6 +46,13 @@ import com.google.common.collect.Lists
 import groovy.transform.CompileStatic
 import org.apache.log4j.Logger
 
+import java.util.concurrent.Callable
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.Executors
+import java.util.concurrent.Future
+
+import static com.eucalyptus.cloud.VmInstanceLifecycleHelpers.*
+import static com.eucalyptus.cloud.VmInstanceLifecycleHelpers.NetworkResourceVmInstanceLifecycleHelper.NetworkResourcesKey
 import static com.eucalyptus.compute.common.network.NetworkingFeature.ElasticIPs
 
 /**
@@ -57,10 +67,12 @@ class EdgeNetworkingService extends NetworkingServiceSupport {
     super( logger )
   }
 
+  def private static ExecutorService allocThreads = Executors.newCachedThreadPool();
   @Override
   protected PrepareNetworkResourcesResponseType prepareWithRollback( final PrepareNetworkResourcesType request,
                                                                      final List<NetworkResource> resources ) {
-    request.getResources( ).each { NetworkResource networkResource ->
+    def futures = request.getResources( ).collect { NetworkResource networkResource ->
+      allocThreads.submit({->
         switch( networkResource ) {
           case PublicIPResource:
             resources.addAll( preparePublicIp( request, (PublicIPResource) networkResource ) )
@@ -69,7 +81,9 @@ class EdgeNetworkingService extends NetworkingServiceSupport {
             resources.addAll( preparePrivateIp( request, (PrivateIPResource) networkResource ) )
             break
         }
+      } as Callable)
     }
+    futures.each {Future f -> f.get()}
 
     PrepareNetworkResourcesResponseType.cast( request.reply( new PrepareNetworkResourcesResponseType(
         prepareNetworkResourcesResultType: new PrepareNetworkResourcesResultType(
@@ -115,6 +129,15 @@ class EdgeNetworkingService extends NetworkingServiceSupport {
 
   @Override
   UpdateNetworkResourcesResponseType update( final UpdateNetworkResourcesType request ) {
+    def nodeState = Clusters.instance.lookup(request.cluster).nodeState;
+    [nodeState.@pendingTokens, nodeState.@submittedTokens].each { tokens ->
+      def inflightAddresses = tokens.collect { ResourceToken rscToken ->
+        rscToken.getAttribute(NetworkResourcesKey)
+      }.findAll {
+        it instanceof PrivateIPResource
+      }.collect { PrivateIPResource privIpRsc -> privIpRsc.value }
+      request.resources.privateIps += inflightAddresses
+    }
     PrivateAddresses.releasing( request.resources.privateIps, request.cluster )
     UpdateNetworkResourcesResponseType.cast( request.reply( new UpdateNetworkResourcesResponseType( ) ) )
   }
@@ -131,7 +154,7 @@ class EdgeNetworkingService extends NetworkingServiceSupport {
     final String zone = request.availabilityZone
     final Iterable<Integer> addresses = NetworkConfigurations.getPrivateAddresses( zone )
     if ( privateIPResource.value ) { // handle restore
-      if ( Iterators.contains( addresses.iterator( ), privateIPResource.value ) ) {
+      if ( Iterators.contains( addresses.iterator( ), PrivateAddresses.asInteger( privateIPResource.value ) ) ) {
         try {
           resource = new PrivateIPResource(
               value: PrivateAddresses.allocate( [ PrivateAddresses.asInteger( privateIPResource.value ) ] ),
diff --git a/clc/modules/cluster-manager/src/main/java/com/eucalyptus/network/config/NetworkConfigurations.groovy b/clc/modules/cluster-manager/src/main/java/com/eucalyptus/network/config/NetworkConfigurations.groovy
index 8a0e87d..a7be153 100644
--- a/clc/modules/cluster-manager/src/main/java/com/eucalyptus/network/config/NetworkConfigurations.groovy
+++ b/clc/modules/cluster-manager/src/main/java/com/eucalyptus/network/config/NetworkConfigurations.groovy
@@ -44,6 +44,9 @@ import com.google.common.base.Splitter
 import com.google.common.base.Strings
 import com.google.common.base.Supplier
 import com.google.common.base.Suppliers
+import com.google.common.cache.CacheBuilder
+import com.google.common.cache.CacheLoader
+import com.google.common.cache.LoadingCache
 import com.google.common.collect.Iterables
 import com.google.common.collect.Lists
 import com.google.common.collect.Maps
@@ -183,12 +186,19 @@ class NetworkConfigurations {
     Lists.newArrayList( NetworkConfigurations.iterateRanges( NetworkConfigurations.getPrivateAddressRanges( configuration, clusterName ) ) )
   }
 
-  static Iterable<Integer> getPrivateAddresses( String clusterName ) {
+  private static LoadingCache<String,Iterable<Integer>> privateAddressCache = CacheBuilder.newBuilder().concurrencyLevel(128).expireAfterAccess(1, TimeUnit.MINUTES).build(new CacheLoader<String, Iterable<Integer>>() {
+    @Override
+    Iterable<Integer> load(String clusterName) throws Exception {
       Optional<NetworkConfiguration> configuration = NetworkConfigurations.networkConfiguration
       if (!configuration.present) {
         throw new IllegalStateException("Networking configuration not found for cluster '${clusterName}'")
       }
-    NetworkConfigurations.getPrivateAddresses( configuration.get( ), clusterName )
+      return NetworkConfigurations.getPrivateAddresses(configuration.get(), clusterName);
+    }
+  })
+
+  static Iterable<Integer> getPrivateAddresses(String clusterName) {
+    return privateAddressCache.get(clusterName)
   }
 
   static NetworkConfiguration parse(final String configuration) throws NetworkConfigurationException {
@@ -197,7 +207,8 @@ class NetworkConfigurations {
     final NetworkConfiguration networkConfiguration
     try {
       networkConfiguration = mapper.readValue(new StringReader(configuration) {
-        @Override String toString() { "property" } // overridden for better source in error message
+        @Override
+        String toString() { "property" } // overridden for better source in error message
       }, NetworkConfiguration.class)
     } catch (JsonProcessingException e) {
       throw new NetworkConfigurationException(e.getMessage())
@@ -247,7 +258,8 @@ class NetworkConfigurations {
     }
 
     // Populate values at cluster level
-    clusters.each{ Cluster cluster ->  cluster.with{
+    clusters.each { Cluster cluster ->
+      cluster.with {
         if (!macPrefix) {
           macPrefix = configuration.macPrefix
         }
@@ -260,11 +272,14 @@ class NetworkConfigurations {
         if (cluster.privateIps == null && configuration.privateIps) {
           cluster.privateIps = configuration.privateIps
         } else if (!cluster.privateIps && subnet) {
-        cluster.privateIps = subnet.with{ IPRange.fromSubnet( subnet, netmask ).split( gateway ).collect{ IPRange range -> range.toString( ) } }
+          cluster.privateIps = subnet.with {
+            IPRange.fromSubnet(subnet, netmask).split(gateway).collect { IPRange range -> range.toString() }
+          }
         }
 
         void
-    } }
+      }
+    }
 
     // Remove any global subnets that are used by clusters
     Collection<String> clusterSubnetsAndNetmasks = clusters.collect { Cluster cluster ->
@@ -373,7 +388,8 @@ class NetworkConfigurations {
     }.trim() ?: null
   }
 
-  private static List<String> getFilteredDequotedPropertyList( Map<String,String> properties, String name, Closure filter ) {
+  private
+  static List<String> getFilteredDequotedPropertyList(Map<String, String> properties, String name, Closure filter) {
     final Splitter splitter = Splitter.on(' ').trimResults().omitEmptyStrings()
     Lists.newArrayList(splitter.split(getTrimmedDequotedProperty(properties, name) ?: ''))
     .findAll(filter) as List<String>
