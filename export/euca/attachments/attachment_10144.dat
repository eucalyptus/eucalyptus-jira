<?xml version="1.0"?>
<wsdl:definitions
  targetNamespace="https://iam.amazonaws.com/doc/2010-05-08/"
  xmlns:tns="https://iam.amazonaws.com/doc/2010-05-08/"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:wsa="http://www.w3.org/2005/08/addressing/"
  xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <wsdl:types>

    <xs:schema
      targetNamespace="https://iam.amazonaws.com/doc/2010-05-08/"
      elementFormDefault="qualified">

      <xs:element name="ResponseMetadata">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="RequestId" type="xs:string"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="Error">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Type">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="Receiver"/>
                  <xs:enumeration value="Sender"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="Code" type="xs:string"/>
            <xs:element name="Message" type="xs:string"/>
            <xs:element name="Detail">
              <xs:complexType>
                <xs:sequence>
                  <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute namespace="##other" processContents="lax"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ErrorResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:Error" maxOccurs="unbounded"/>
            <xs:element name="RequestId" type="xs:string"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroups">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="PathPrefix" type="tns:pathPrefixType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path prefix for filtering the results. For example: <code>/division_abc/subdivision_xyz/</code>, which
                  would get all groups whose path starts with <code>/division_abc/subdivision_xyz/</code>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing all groups.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of groups you want in the response.
                  If there are additional groups beyond the maximum you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupsResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListGroupsResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupsResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListGroups</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Groups" type="tns:groupListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of groups.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more groups to list. If your results were truncated,
                  you can make a subsequent pagination request using the <code>Marker</code> request parameter to retrieve more
                  groups in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use 
                  for the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteAccessKey">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User whose key you want to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AccessKeyId" type="tns:accessKeyIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Access Key ID for the Access Key ID and Secret Access Key you want to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteAccessKeyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListSigningCertificates">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the User.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a
                  response where the results are truncated. Set it to the value of the <code>Marker</code> element in
                  the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of certificate IDs you want in 
                  the response. If there are additional certificate IDs beyond the maximum you specify, the <code>IsTruncated</code>
                  response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListSigningCertificatesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListSigningCertificatesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListSigningCertificatesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListSigningCertificates</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Certificates" type="tns:certificateListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of the User's signing certificate information.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more certificate IDs to list. If your results were truncated,
                  you can make a subsequent pagination request using the <code>Marker</code> request parameter to retrieve
                  more certificates in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for the 
                  <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadSigningCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User the signing certificate is for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateBody" type="tns:certificateBodyType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the signing certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadSigningCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:UploadSigningCertificateResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadSigningCertificateResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>UploadSigningCertificate</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Certificate" type="tns:SigningCertificate">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteUserPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteUserPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="PutUserPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User to associate the policy with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="PutUserPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListServerCertificates">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="PathPrefix" type="tns:pathPrefixType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path prefix for filtering the results. For example: <code>/company/servercerts</code> would get all server
              	certificates for which the path starts with <code>/company/servercerts</code>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing all server certificates.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of server certificates you want in the response. If
                  there are additional server certificates beyond the maximum you specify, the <code>IsTruncated</code> response element will
                  be set to <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListServerCertificatesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListServerCertificatesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListServerCertificatesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListServerCertificates</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="ServerCertificateMetadataList" type="tns:serverCertificateMetadataListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of server certificates.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more server certificates to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more server certificates in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for
                  the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUserPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User who the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document to get.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUserPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetUserPolicyResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUserPolicyResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetUserPolicy</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The User the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the policy.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateLoginProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User whose login profile you want to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Password" type="tns:passwordType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The new password for the User name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateLoginProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateServerCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="ServerCertificateName" type="tns:serverCertificateNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the server certificate that you want to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewPath" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The new path for the server certificate. Include this only if you are updating the server certificate's path.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewServerCertificateName" type="tns:serverCertificateNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The new name for the server certificate. Include this only if you are updating the server certificate's name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateServerCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateUser">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User to update.  If you're changing the name of the User, this is the original User name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewPath" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>New path for the User. Include this parameter only if you're changing the User's path.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewUserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>New name for the User. Include this parameter only if you're changing the User's name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateUserResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteLoginProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User whose login profile you want to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteLoginProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateSigningCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User the signing certificate belongs to.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateId" type="tns:certificateIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The ID of the signing certificate you want to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Status" type="tns:statusType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The status you want to assign to the certificate. <code>Active</code> means the certificate can be
                   used for API calls to AWS, while <code>Inactive</code> means the certificate cannot be used.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateSigningCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteGroupPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteGroupPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUsers">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="PathPrefix" type="tns:pathPrefixType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path prefix for filtering the results. For example: <code>/division_abc/subdivision_xyz/</code>, which
                  would get all User names whose path starts with <code>/division_abc/subdivision_xyz/</code>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing all User names.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results to indicate the maximum number of User names you want in the response. If
                  there are additional User names beyond the maximum you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUsersResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListUsersResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUsersResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListUsers</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Users" type="tns:userListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of User names.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more User names to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more Users in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for
                  the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to update. If you're changing the name of the group, this is the original name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewPath" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>New path for the group. Only include this if changing the group's path.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewGroupName" type="tns:groupNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>New name for the group. Only include this if changing the group's name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetServerCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="ServerCertificateName" type="tns:serverCertificateNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the server certificate you want to retrieve information about.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetServerCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetServerCertificateResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetServerCertificateResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetServerCertificate</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="ServerCertificate" type="tns:ServerCertificate">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the server certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="PutGroupPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to associate the policy with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="PutGroupPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateUser">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="Path" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path for the User name. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User to create.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateUserResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:CreateUserResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateUserResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>CreateUser</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="User" type="tns:User" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the User.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteSigningCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User the signing certificate belongs to.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateId" type="tns:certificateIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>ID of the signing certificate to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteSigningCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="EnableMFADevice">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User for whom you want to enable the MFA device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="SerialNumber" type="tns:serialNumberType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The serial number that uniquely identifies the MFA device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AuthenticationCode1" type="tns:authenticationCodeType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>An authentication code emitted by the device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AuthenticationCode2" type="tns:authenticationCodeType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A subsequent authentication code emitted by the device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="EnableMFADeviceResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUserPolicies">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the User to list policies for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response where the results 
                  are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of policy names you want in the response.
                  If there are additional policy names beyond the maximum you specify, the <code>IsTruncated</code> response element is
                  <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUserPoliciesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListUserPoliciesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUserPoliciesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListUserPolicies</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="PolicyNames" type="tns:policyNameListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of policy names.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more policy names to list. If your results were truncated,
                  you can make a subsequent pagination request using the <code>Marker</code> request parameter to retrieve
                  more policy names in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to 
                  use for the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListAccessKeys">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response
                  where the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of keys you want in the response. If there are
                  additional keys beyond the maximum you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListAccessKeysResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListAccessKeysResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListAccessKeysResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListAccessKeys</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="AccessKeyMetadata" type="tns:accessKeyMetadataListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of access key metadata.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more keys to list. If your results were truncated, you can make a subsequent
                  pagination request using the <code>Marker</code> request parameter to retrieve more keys in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for the <code>Marker</code>
                  parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetLoginProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User whose login profile you want to retrieve.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetLoginProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetLoginProfileResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetLoginProfileResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetLoginProfile</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="LoginProfile" type="tns:LoginProfile">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Login profile for the User name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupsForUser">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the User to list groups for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of groups you want in the response.
                  If there are additional groups beyond the maximum you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupsForUserResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListGroupsForUserResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupsForUserResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListGroupsForUser</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Groups" type="tns:groupListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of groups.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more groups to list. If your results were truncated,
                  you can make a subsequent pagination request using the <code>Marker</code> request parameter to retrieve more
                  groups in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use 
                  for the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="Path" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path to the group. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to create. Do not include the path in this value.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:CreateGroupResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateGroupResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>CreateGroup</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Group" type="tns:Group">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the group.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadServerCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="Path" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path for the server certificate. For more information about paths, see 
              	<a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="ServerCertificateName" type="tns:serverCertificateNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name for the server certificate. Do not include the path in this value.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateBody" type="tns:certificateBodyType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the public key certificate in PEM-encoded format.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PrivateKey" type="tns:privateKeyType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the private key in PEM-encoded format.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateChain" type="tns:certificateChainType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the certificate chain. This is typically a concatenation of the PEM-encoded public key certificates of the chain.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadServerCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:UploadServerCertificateResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadServerCertificateResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>UploadServerCertificate</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="ServerCertificateMetadata" type="tns:ServerCertificateMetadata" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The meta information of the uploaded server certificate without its certificate body, certificate chain, and private key.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroupPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document to get.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroupPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetGroupPolicyResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroupPolicyResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetGroupPolicy</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The group the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the policy.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteUser">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteUserResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeactivateMFADevice">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User whose MFA device you want to deactivate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="SerialNumber" type="tns:serialNumberType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The serial number that uniquely identifies the MFA device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeactivateMFADeviceResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="RemoveUserFromGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User to remove.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="RemoveUserFromGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteServerCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="ServerCertificateName" type="tns:serverCertificateNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the server certificate you want to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteServerCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupPolicies">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the group to list policies for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response where the results 
                  are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of policy names you want in the response.
                  If there are additional policy names beyond the maximum you specify, the <code>IsTruncated</code> response element is
                  <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupPoliciesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListGroupPoliciesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupPoliciesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListGroupPolicies</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="PolicyNames" type="tns:policyNameListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of policy names.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more policy names to list. If your results were truncated,
                  you can make a subsequent pagination request using the <code>Marker</code> request parameter to retrieve
                  more policy names in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to 
                  use for the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateLoginProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User to create a login profile for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Password" type="tns:passwordType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The new password for the User name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateLoginProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:CreateLoginProfileResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateLoginProfileResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>CreateLoginProfile</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="LoginProfile" type="tns:LoginProfile">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The new login profile.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateAccessKey">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The User name that the new key will belong to.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateAccessKeyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:CreateAccessKeyResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateAccessKeyResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>CreateAccessKey</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="AccessKey" type="tns:AccessKey">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the access key.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUser">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User to get information about.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to the User making the request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUserResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetUserResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUserResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetUser</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="User" type="tns:User">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the User.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ResyncMFADevice">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User whose MFA device you want to resynchronize.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="SerialNumber" type="tns:serialNumberType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Serial number that uniquely identifies the MFA device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AuthenticationCode1" type="tns:authenticationCodeType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>An authentication code emitted by the device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AuthenticationCode2" type="tns:authenticationCodeType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A subsequent authentication code emitted by the device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ResyncMFADeviceResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListMFADevices">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User whose MFA devices you want to list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response
                  where the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of keys you want in the response. If there are
                  additional keys beyond the maximum you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListMFADevicesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListMFADevicesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListMFADevicesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListMFADevices</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="MFADevices" type="tns:mfaDeviceListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of MFA devices.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more User names to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more User names in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for
                  the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateAccessKey">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User whose key you want to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AccessKeyId" type="tns:accessKeyIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Access Key ID of the Secret Access Key you want to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Status" type="tns:statusType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The status you want to assign to the Secret Access Key. <code>Active</code> means the key can be used
                  for API calls to AWS, while <code>Inactive</code> means the key cannot be used.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateAccessKeyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="AddUserToGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User to add.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="AddUserToGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response
                  where the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of User names you want in the response.
                  If there are additional User names beyond the maximum you specify, the <code>IsTruncated</code> response element is 
                  <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetGroupResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroupResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetGroup</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Group" type="tns:Group">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the group.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Users" type="tns:userListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of Users in the group.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more User names to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more User names in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If IsTruncated is <code>true</code>, then this element is present and contains the value to use for the <code>Marker</code> parameter in
                  a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:complexType name="serverCertificateMetadataListType">
        <xs:sequence>
          <xs:element name="member" type="tns:ServerCertificateMetadata" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="markerType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0020-\u00FF]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="320"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="statusType">
        <xs:restriction base="xs:string">
          <xs:enumeration value="Active"/>
          <xs:enumeration value="Inactive"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="policyNameType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="pathPrefixType">
        <xs:restriction base="xs:string">
          <xs:pattern value="\u002F[\u0021-\u007F]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="512"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="ServerCertificate">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The ServerCertificate data type contains information about a server certificate.</p>
        
            <p>This data type is used as a response element in the action <a>GetServerCertificate</a>.</p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="ServerCertificateMetadata" type="tns:ServerCertificateMetadata">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The meta information of the server certificate, such as its name, path, ID, and ARN.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateBody" type="tns:certificateBodyType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the public key certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateChain" type="tns:certificateChainType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the public key certificate chain.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="certificateChainType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0009\u000A\u000D\u0020-\u00FF]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="2097152"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="userNameType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="maxItemsType">
        <xs:restriction base="xs:integer">
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="certificateBodyType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0009\u000A\u000D\u0020-\u00FF]+"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="16384"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="groupListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The groupListType data type contains a list of groups.</p>
            
            <p>
            This data type is used as a response element in the action <a>ListGroups</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:Group" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="ServerCertificateMetadata">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>ServerCertificateMetadata contains information about a server certificate without its certificate body, certificate chain, and private key.</p>
        
            <p>This data type is used as a response element in the action <a>UploadServerCertificate</a> and <a>ListServerCertificates</a>.</p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="Path" type="tns:pathType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Path to the server certificate. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="ServerCertificateName" type="tns:serverCertificateNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name that identifies the server certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="ServerCertificateId" type="tns:idType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The stable and unique string identifying the server certificate. For more information about IDs, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Arn" type="tns:arnType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Amazon Resource Name (ARN) specifying the server certificate. For more information about ARNs and how
                  to use them in policies, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UploadDate" type="xs:dateTime" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the server certificate was uploaded.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="User">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The User data type contains information about a User.</p>
            
            <p>
            This data type is used as a response element in the following actions:</p>
        	<ul>
              <li><p><a>CreateUser</a></p></li>
              <li><p><a>GetUser</a></p></li>
              <li><p><a>ListUsers</a></p></li> 
            </ul>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="Path" type="tns:pathType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Path to the User name. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name identifying the User.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UserId" type="tns:idType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The stable and unique string identifying the User. For more information about IDs, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Arn" type="tns:arnType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Amazon Resource Name (ARN) specifying the User. For more information about ARNs and how
                  to use them in policies, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="SigningCertificate">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The SigningCertificate data type contains information about an X.509 signing certificate.</p>
            
            <p>
            This data type is used as a response element in the actions <a>UploadSigningCertificate</a> and <a>ListSigningCertificates</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User the signing certificate is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateId" type="tns:certificateIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The ID for the signing certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateBody" type="tns:certificateBodyType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the signing certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Status" type="tns:statusType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The status of the signing certificate. <code>Active</code> means the key is valid for
                  API calls, while <code>Inactive</code> means it is not.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UploadDate" type="xs:dateTime" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the signing certificate was uploaded.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="mfaDeviceListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The mfaDeviceListType data type contains a list of MFA devices.</p>
        
            <p>
            This data type is used as a response element in the action <a>ListMFADevices</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:MFADevice" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="policyDocumentType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0009\u000A\u000D\u0020-\u00FF]+"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="131072"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="Group">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The Group data type contains information about a group.</p>
            
        	<p>
            This data type is used as a response element in the following actions:</p>
            <ul>
        	  <li><a>CreateGroup</a></li>
        	  <li><a>GetGroup</a></li>
        	  <li><a>ListGroups</a></li>
            </ul>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="Path" type="tns:pathType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Path to the group. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name that identifies the group.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="GroupId" type="tns:idType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The stable and unique string identifying the group. For more information about IDs, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Arn" type="tns:arnType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Amazon Resource Name (ARN) specifying the group. For more information about ARNs and how
                  to use them in policies, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="serverCertificateNameType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="certificateIdType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w]*"/>
          <xs:minLength value="24"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="passwordType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0009\u000A\u000D\u0020-\u00FF]+"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="userListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The userListType data type contains a list of Users.</p>
            
            <p>
            This data type is used as a response element in the actions <a>GetGroup</a> and <a>ListUsers</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:User" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="AccessKeyMetadata">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The AccessKey data type contains information about an AWS access key, without its secret key.</p>
            
            <p>
            This data type is used as a response element in the action <a>ListAccessKeys</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User the key is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AccessKeyId" type="tns:accessKeyIdType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The ID for this access key.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Status" type="tns:statusType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The status of the access key. <code>Active</code> means the key is valid for
                  API calls, while <code>Inactive</code> means it is not.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CreateDate" type="xs:dateTime" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the access key was created.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="pathType">
        <xs:restriction base="xs:string">
          <xs:pattern value="(\u002F)|(\u002F[\u0021-\u007F]+\u002F)"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="512"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="arnType">
        <xs:restriction base="xs:string">
          <xs:minLength value="20"/>
          <xs:maxLength value="2048"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="certificateListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The certificateListType data type contains a list of signing certificates.</p>
            
            <p>
            This data type is used as a response element in the action <a>ListSigningCertificates</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:SigningCertificate" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="idType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w]*"/>
          <xs:minLength value="16"/>
          <xs:maxLength value="32"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="accessKeyMetadataListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The accessKeyMetadataListType data type contains a list of access key metadata.</p>
            
            <p>
            This data type is used as a response element in the action <a>ListAccessKeys</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:AccessKeyMetadata" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="MFADevice">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The MFADevice data type contains information about an MFA Device.</p>
            
        	<p>
            This data type is used as a response element in the action <a>ListMFADevices</a>.
        
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The User with whom the MFA device is associated.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="SerialNumber" type="tns:serialNumberType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Serial number that uniquely identifies the MFA device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="authenticationCodeType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\d]*"/>
          <xs:minLength value="6"/>
          <xs:maxLength value="6"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="privateKeyType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0009\u000A\u000D\u0020-\u00FF]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="16384"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="policyNameListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The policyNameListType data type contains a list of policy names.</p>
        
            <p>
            This data type is used as a response element in the action <a>ListPolicies</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:policyNameType" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="serialNumberType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w]*"/>
          <xs:minLength value="9"/>
          <xs:maxLength value="48"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="groupNameType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="AccessKey">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The AccessKey data type contains information about an AWS access key.</p>
            
            <p>
            This data type is used as a response element in the actions <a>CreateAccessKey</a> and <a>ListAccessKeys</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the User the key is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AccessKeyId" type="tns:accessKeyIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The ID for this access key.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Status" type="tns:statusType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The status of the access key. <code>Active</code> means the key is valid for
                  API calls, while <code>Inactive</code> means it is not.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="SecretAccessKey" type="xs:string">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The secret key used to sign requests.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CreateDate" type="xs:dateTime" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the access key was created.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="accessKeyIdType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w]*"/>
          <xs:minLength value="16"/>
          <xs:maxLength value="32"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="LoginProfile">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The LoginProfile data type contains information about a login profile for a User.</p>
            
        	<p>
            This data type is used as a response element in the actions <a>CreateLoginProfile</a> and <a>GetLoginProfile</a>.
        	</p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the User, which can be used for logins.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

    </xs:schema>

  </wsdl:types>

  <wsdl:message name="ListGroupsRequestMsg">
    <wsdl:part element="tns:ListGroups" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListGroupsResponseMsg">
    <wsdl:part element="tns:ListGroupsResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteAccessKeyRequestMsg">
    <wsdl:part element="tns:DeleteAccessKey" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteAccessKeyResponseMsg">
    <wsdl:part element="tns:DeleteAccessKeyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListSigningCertificatesRequestMsg">
    <wsdl:part element="tns:ListSigningCertificates" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListSigningCertificatesResponseMsg">
    <wsdl:part element="tns:ListSigningCertificatesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UploadSigningCertificateRequestMsg">
    <wsdl:part element="tns:UploadSigningCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="UploadSigningCertificateResponseMsg">
    <wsdl:part element="tns:UploadSigningCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteUserPolicyRequestMsg">
    <wsdl:part element="tns:DeleteUserPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteUserPolicyResponseMsg">
    <wsdl:part element="tns:DeleteUserPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="PutUserPolicyRequestMsg">
    <wsdl:part element="tns:PutUserPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="PutUserPolicyResponseMsg">
    <wsdl:part element="tns:PutUserPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListServerCertificatesRequestMsg">
    <wsdl:part element="tns:ListServerCertificates" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListServerCertificatesResponseMsg">
    <wsdl:part element="tns:ListServerCertificatesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetUserPolicyRequestMsg">
    <wsdl:part element="tns:GetUserPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetUserPolicyResponseMsg">
    <wsdl:part element="tns:GetUserPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateLoginProfileRequestMsg">
    <wsdl:part element="tns:UpdateLoginProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateLoginProfileResponseMsg">
    <wsdl:part element="tns:UpdateLoginProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateServerCertificateRequestMsg">
    <wsdl:part element="tns:UpdateServerCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateServerCertificateResponseMsg">
    <wsdl:part element="tns:UpdateServerCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateUserRequestMsg">
    <wsdl:part element="tns:UpdateUser" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateUserResponseMsg">
    <wsdl:part element="tns:UpdateUserResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteLoginProfileRequestMsg">
    <wsdl:part element="tns:DeleteLoginProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteLoginProfileResponseMsg">
    <wsdl:part element="tns:DeleteLoginProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateSigningCertificateRequestMsg">
    <wsdl:part element="tns:UpdateSigningCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateSigningCertificateResponseMsg">
    <wsdl:part element="tns:UpdateSigningCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteGroupPolicyRequestMsg">
    <wsdl:part element="tns:DeleteGroupPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteGroupPolicyResponseMsg">
    <wsdl:part element="tns:DeleteGroupPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListUsersRequestMsg">
    <wsdl:part element="tns:ListUsers" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListUsersResponseMsg">
    <wsdl:part element="tns:ListUsersResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateGroupRequestMsg">
    <wsdl:part element="tns:UpdateGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateGroupResponseMsg">
    <wsdl:part element="tns:UpdateGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetServerCertificateRequestMsg">
    <wsdl:part element="tns:GetServerCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetServerCertificateResponseMsg">
    <wsdl:part element="tns:GetServerCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="PutGroupPolicyRequestMsg">
    <wsdl:part element="tns:PutGroupPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="PutGroupPolicyResponseMsg">
    <wsdl:part element="tns:PutGroupPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateUserRequestMsg">
    <wsdl:part element="tns:CreateUser" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateUserResponseMsg">
    <wsdl:part element="tns:CreateUserResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteSigningCertificateRequestMsg">
    <wsdl:part element="tns:DeleteSigningCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteSigningCertificateResponseMsg">
    <wsdl:part element="tns:DeleteSigningCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="EnableMFADeviceRequestMsg">
    <wsdl:part element="tns:EnableMFADevice" name="body"/>
  </wsdl:message>

  <wsdl:message name="EnableMFADeviceResponseMsg">
    <wsdl:part element="tns:EnableMFADeviceResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListUserPoliciesRequestMsg">
    <wsdl:part element="tns:ListUserPolicies" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListUserPoliciesResponseMsg">
    <wsdl:part element="tns:ListUserPoliciesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListAccessKeysRequestMsg">
    <wsdl:part element="tns:ListAccessKeys" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListAccessKeysResponseMsg">
    <wsdl:part element="tns:ListAccessKeysResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetLoginProfileRequestMsg">
    <wsdl:part element="tns:GetLoginProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetLoginProfileResponseMsg">
    <wsdl:part element="tns:GetLoginProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListGroupsForUserRequestMsg">
    <wsdl:part element="tns:ListGroupsForUser" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListGroupsForUserResponseMsg">
    <wsdl:part element="tns:ListGroupsForUserResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateGroupRequestMsg">
    <wsdl:part element="tns:CreateGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateGroupResponseMsg">
    <wsdl:part element="tns:CreateGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UploadServerCertificateRequestMsg">
    <wsdl:part element="tns:UploadServerCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="UploadServerCertificateResponseMsg">
    <wsdl:part element="tns:UploadServerCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetGroupPolicyRequestMsg">
    <wsdl:part element="tns:GetGroupPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetGroupPolicyResponseMsg">
    <wsdl:part element="tns:GetGroupPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteUserRequestMsg">
    <wsdl:part element="tns:DeleteUser" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteUserResponseMsg">
    <wsdl:part element="tns:DeleteUserResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeactivateMFADeviceRequestMsg">
    <wsdl:part element="tns:DeactivateMFADevice" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeactivateMFADeviceResponseMsg">
    <wsdl:part element="tns:DeactivateMFADeviceResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="RemoveUserFromGroupRequestMsg">
    <wsdl:part element="tns:RemoveUserFromGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="RemoveUserFromGroupResponseMsg">
    <wsdl:part element="tns:RemoveUserFromGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteServerCertificateRequestMsg">
    <wsdl:part element="tns:DeleteServerCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteServerCertificateResponseMsg">
    <wsdl:part element="tns:DeleteServerCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListGroupPoliciesRequestMsg">
    <wsdl:part element="tns:ListGroupPolicies" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListGroupPoliciesResponseMsg">
    <wsdl:part element="tns:ListGroupPoliciesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateLoginProfileRequestMsg">
    <wsdl:part element="tns:CreateLoginProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateLoginProfileResponseMsg">
    <wsdl:part element="tns:CreateLoginProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateAccessKeyRequestMsg">
    <wsdl:part element="tns:CreateAccessKey" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateAccessKeyResponseMsg">
    <wsdl:part element="tns:CreateAccessKeyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetUserRequestMsg">
    <wsdl:part element="tns:GetUser" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetUserResponseMsg">
    <wsdl:part element="tns:GetUserResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ResyncMFADeviceRequestMsg">
    <wsdl:part element="tns:ResyncMFADevice" name="body"/>
  </wsdl:message>

  <wsdl:message name="ResyncMFADeviceResponseMsg">
    <wsdl:part element="tns:ResyncMFADeviceResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListMFADevicesRequestMsg">
    <wsdl:part element="tns:ListMFADevices" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListMFADevicesResponseMsg">
    <wsdl:part element="tns:ListMFADevicesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateAccessKeyRequestMsg">
    <wsdl:part element="tns:UpdateAccessKey" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateAccessKeyResponseMsg">
    <wsdl:part element="tns:UpdateAccessKeyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="AddUserToGroupRequestMsg">
    <wsdl:part element="tns:AddUserToGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="AddUserToGroupResponseMsg">
    <wsdl:part element="tns:AddUserToGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetGroupRequestMsg">
    <wsdl:part element="tns:GetGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetGroupResponseMsg">
    <wsdl:part element="tns:GetGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteGroupRequestMsg">
    <wsdl:part element="tns:DeleteGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteGroupResponseMsg">
    <wsdl:part element="tns:DeleteGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:portType name="AWSIdentityManagementV20100508PortType">

    <wsdl:operation name="ListGroups">
      <wsdl:documentation><![CDATA[
    <p>Lists the groups that have the specified path prefix.</p>
     
    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListGroups
&PathPrefix=/division_abc/subdivision_xyz/
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListGroupsResponse>
   <ListGroupsResult>
      <Groups>
         <member>
            <Path>/division_abc/subdivision_xyz/</Path>
            <GroupName>Admins</GroupName>
            <GroupId>AGPACKCEVSQ6C2EXAMPLE</GroupId>
            <Arn>arn:aws:iam::123456789012:group/Admins</Arn>
         </member>
         <member>
            <Path>/division_abc/subdivision_xyz/product_1234/engineering/
            </Path>
            <GroupName>Test</GroupName>
            <GroupId>AGP2MAB8DPLSRHEXAMPLE</GroupId>
            <Arn>arn:aws:iam::123456789012:group
            /division_abc/subdivision_xyz/product_1234/engineering/Test</Arn>
         </member>
         <member>
            <Path>/division_abc/subdivision_xyz/product_1234/</Path>
            <GroupName>Managers</GroupName>
            <GroupId>AGPIODR4TAW7CSEXAMPLE</GroupId>
            <Arn>arn:aws:iam::123456789012
            :group/division_abc/subdivision_xyz/product_1234/Managers</Arn>
         </member>
      </Groups>
      <IsTruncated>false</IsTruncated>
   </ListGroupsResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListGroupsResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListGroupsRequestMsg" wsa:Action="urn:ListGroups"/>
      <wsdl:output message="tns:ListGroupsResponseMsg" wsa:Action="urn:ListGroups:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteAccessKey">
      <wsdl:documentation><![CDATA[
    <p>Deletes the access key associated with the specified User.</p>

<p>If you do not specify a User name, IAM determines the User name implicitly based on the AWS
    Access Key ID signing the request. Because this action works for access keys under the AWS Account,
    you can use this API to manage root credentials even if the AWS Account has no associated Users.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteAccessKey
&UserName=Bob
&AccessKeyId=AKIAIOSFODNN7EXAMPLE
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteAccessKeyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteAccessKeyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteAccessKeyRequestMsg" wsa:Action="urn:DeleteAccessKey"/>
      <wsdl:output message="tns:DeleteAccessKeyResponseMsg" wsa:Action="urn:DeleteAccessKey:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListSigningCertificates">
      <wsdl:documentation><![CDATA[
    <p>Returns information about the signing certificates associated with the specified User. If there
    are none, the action returns an empty list.</p>

    <p>Although each User is limited to a small number of signing certificates, you can still paginate
    the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

	<p>If the <code>UserName</code> field is not specified, the UserName is determined implicitly
	based on the AWS Access Key ID used to sign the request. Because this action works for access
	keys under the AWS Account, this API can be used to manage root credentials even if the AWS Account has
	no associated Users.</p>


    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListSigningCertificates
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListSigningCertificatesResponse>
   <ListSigningCertificatesResult>
      <UserName>Bob</UserName>
      <Certificates>
         <member>
            <UserName>Bob</UserName>
            <CertificateId>TA7SMP42TDN5Z26OBPJE7EXAMPLE</CertificateId>
            <CertificateBody>-----BEGIN CERTIFICATE-----
    MIICdzCCAeCgAwIBAgIGANc+Ha2wMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNVBAYT
    AlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNBV1MxITAfBgNVBAMT
    GEFXUyBMaW1pdGVkLUFzc3VyYW5jZSBDQTAeFw0wOTAyMDQxNzE5MjdaFw0xMDAy
    MDQxNzE5MjdaMFIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMRcw
    FQYDVQQLEw5BV1MtRGV2ZWxvcGVyczEVMBMGA1UEAxMMNTdxNDl0c3ZwYjRtMIGf
    MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCpB/vsOwmT/O0td1RqzKjttSBaPjbr
    dqwNe9BrOyB08fw2+Ch5oonZYXfGUrT6mkYXH5fQot9HvASrzAKHO596FdJA6DmL
    ywdWe1Oggk7zFSXO1Xv+3vPrJtaYxYo3eRIp7w80PMkiOv6M0XK8ubcTouODeJbf
    suDqcLnLDxwsvwIDAQABo1cwVTAOBgNVHQ8BAf8EBAMCBaAwFgYDVR0lAQH/BAww
    CgYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQULGNaBphBumaKbDRK
    CAi0mH8B3mowDQYJKoZIhvcNAQEFBQADgYEAuKxhkXaCLGcqDuweKtO/AEw9ZePH
    wr0XqsaIK2HZboqruebXEGsojK4Ks0WzwgrEynuHJwTn760xe39rSqXWIOGrOBaX
    wFpWHVjTFMKk+tSDG1lssLHyYWWdFFU4AnejRGORJYNaRHgVTKjHphc5jEhHm0BX
    AEaHzTpmEXAMPLE=
    -----END CERTIFICATE-----</CertificateBody>
            <Status>Active</Status>
         </member>
      </Certificates>
      <IsTruncated>false</IsTruncated>
   </ListSigningCertificatesResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListSigningCertificatesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListSigningCertificatesRequestMsg" wsa:Action="urn:ListSigningCertificates"/>
      <wsdl:output message="tns:ListSigningCertificatesResponseMsg" wsa:Action="urn:ListSigningCertificates:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UploadSigningCertificate">
      <wsdl:documentation><![CDATA[
    <p>Uploads an X.509 signing certificate and associates it with the specified User. Some AWS services
	use X.509 signing certificates to validate requests that are signed with a
    corresponding private key. When you upload the certificate, its default status is <code>Active</code>.</p>

	<p>If the <code>UserName</code> field is not specified, the User name is determined implicitly
	based on the AWS Access Key ID used to sign the request. Because this action works for access
	keys under the AWS Account, this API can be used to manage root credentials even if the AWS Account
	has no associated Users.</p>

    <note>Because the body of a X.509 certificate can be large, you should use POST rather than GET when
    calling <code>UploadSigningCertificate</code>. For more information,
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?IAM_UsingQueryAPI.html" target="_blank">Making Query Requests</a> in <i>Using AWS Identity and Access Management</i>.</note>

    <examples>

      <queryrequest>
POST / HTTP/1.1
Host: iam.amazonaws.com
Content-Type: application/x-www-form-urlencoded

Action=UploadSigningCertificate
&UserName=Bob
&CertificateBody=-----BEGIN CERTIFICATE-----
    MIICdzCCAeCgAwIBAgIGANc+Ha2wMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNVBAYT
    AlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNBV1MxITAfBgNVBAMT
    GEFXUyBMaW1pdGVkLUFzc3VyYW5jZSBDQTAeFw0wOTAyMDQxNzE5MjdaFw0xMDAy
    MDQxNzE5MjdaMFIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMRcw
    FQYDVQQLEw5BV1MtRGV2ZWxvcGVyczEVMBMGA1UEAxMMNTdxNDl0c3ZwYjRtMIGf
    MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCpB/vsOwmT/O0td1RqzKjttSBaPjbr
    dqwNe9BrOyB08fw2+Ch5oonZYXfGUrT6mkYXH5fQot9HvASrzAKHO596FdJA6DmL
    ywdWe1Oggk7zFSXO1Xv+3vPrJtaYxYo3eRIp7w80PMkiOv6M0XK8ubcTouODeJbf
    suDqcLnLDxwsvwIDAQABo1cwVTAOBgNVHQ8BAf8EBAMCBaAwFgYDVR0lAQH/BAww
    CgYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQULGNaBphBumaKbDRK
    CAi0mH8B3mowDQYJKoZIhvcNAQEFBQADgYEAuKxhkXaCLGcqDuweKtO/AEw9ZePH
    wr0XqsaIK2HZboqruebXEGsojK4Ks0WzwgrEynuHJwTn760xe39rSqXWIOGrOBaX
    wFpWHVjTFMKk+tSDG1lssLHyYWWdFFU4AnejRGORJYNaRHgVTKjHphc5jEhHm0BX
    AEaHzTpmEXAMPLE=
    -----END CERTIFICATE-----
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UploadSigningCertificateResponse>
   <UploadSigningCertificateResult>
      <Certificate>
         <UserName>Bob</UserName>
         <CertificateId>TA7SMP42TDN5Z26OBPJE7EXAMPLE</CertificateId>
         <CertificateBody>-----BEGIN CERTIFICATE-----
    MIICdzCCAeCgAwIBAgIGANc+Ha2wMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNVBAYT
    AlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNBV1MxITAfBgNVBAMT
    GEFXUyBMaW1pdGVkLUFzc3VyYW5jZSBDQTAeFw0wOTAyMDQxNzE5MjdaFw0xMDAy
    MDQxNzE5MjdaMFIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMRcw
    FQYDVQQLEw5BV1MtRGV2ZWxvcGVyczEVMBMGA1UEAxMMNTdxNDl0c3ZwYjRtMIGf
    MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCpB/vsOwmT/O0td1RqzKjttSBaPjbr
    dqwNe9BrOyB08fw2+Ch5oonZYXfGUrT6mkYXH5fQot9HvASrzAKHO596FdJA6DmL
    ywdWe1Oggk7zFSXO1Xv+3vPrJtaYxYo3eRIp7w80PMkiOv6M0XK8ubcTouODeJbf
    suDqcLnLDxwsvwIDAQABo1cwVTAOBgNVHQ8BAf8EBAMCBaAwFgYDVR0lAQH/BAww
    CgYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQULGNaBphBumaKbDRK
    CAi0mH8B3mowDQYJKoZIhvcNAQEFBQADgYEAuKxhkXaCLGcqDuweKtO/AEw9ZePH
    wr0XqsaIK2HZboqruebXEGsojK4Ks0WzwgrEynuHJwTn760xe39rSqXWIOGrOBaX
    wFpWHVjTFMKk+tSDG1lssLHyYWWdFFU4AnejRGORJYNaRHgVTKjHphc5jEhHm0BX
    AEaHzTpmEXAMPLE=
    -----END CERTIFICATE-----</CertificateBody>
         <Status>Active</Status>
      </Certificate>
   </UploadSigningCertificateResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UploadSigningCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UploadSigningCertificateRequestMsg" wsa:Action="urn:UploadSigningCertificate"/>
      <wsdl:output message="tns:UploadSigningCertificateResponseMsg" wsa:Action="urn:UploadSigningCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteUserPolicy">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified policy associated with the specified User.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteUserPolicy
&UserName=Bob
&PolicyName=AllAccessPolicy
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteUserPolicyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteUserPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteUserPolicyRequestMsg" wsa:Action="urn:DeleteUserPolicy"/>
      <wsdl:output message="tns:DeleteUserPolicyResponseMsg" wsa:Action="urn:DeleteUserPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="PutUserPolicy">
      <wsdl:documentation><![CDATA[
    <p>Adds (or updates) a policy document associated with the specified User. For information about
    policies, refer to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?PoliciesOverview.html" target="_blank">Overview of Policies</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <p>For information about limits on the number of policies you can associate with a User, see
     <a href="http://docs.amazonwebservices.com/IAM/2010-05-08/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <note>Because policy documents can be large, you should use POST rather than GET when
    calling <code>PutUserPolicy</code>. For more information,
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?IAM_UsingQueryAPI.html" target="_blank">Making Query Requests</a> in <i>Using AWS Identity and Access Management</i>.</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=PutUserPolicy
&UserName=Bob
&PolicyName=AllAccessPolicy
&PolicyDocument={"Statement":[{"Effect":"Allow","Action":"*","Resource":"*"}]}
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<PutUserPolicyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</PutUserPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:PutUserPolicyRequestMsg" wsa:Action="urn:PutUserPolicy"/>
      <wsdl:output message="tns:PutUserPolicyResponseMsg" wsa:Action="urn:PutUserPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListServerCertificates">
      <wsdl:documentation><![CDATA[
    <p>Lists the server certificates that have the specified path prefix. If none exist, the
    action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=ListServerCertificates
&PathPrefix=/company/servercerts
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListServerCertificatesResponse>
  <ListServerCertificatesResult>
    <IsTruncated>false</IsTruncated>
    <ServerCertificateMetadataList>
      <member>
        <ServerCertificateMetadata>
          <ServerCertificateName>ProdServerCert</ServerCertificateName>
          <Path>/company/servercerts/</Path>
          <Arn>arn:aws:iam::123456789012:server-certificate/company/servercerts/ProdServerCert</Arn>
          <UploadDate>2010-05-08T01:02:03.004Z</UploadDate>
          <ServerCertificateId>ASCACKCEVSQ6CEXAMPLE1</ServerCertificateId>
        </ServerCertificateMetadata>
      </member>
      <member>
        <ServerCertificateMetadata>
          <ServerCertificateName>BetaServerCert</ServerCertificateName>
          <Path>/company/servercerts/</Path>
          <Arn>arn:aws:iam::123456789012:server-certificate/company/servercerts/BetaServerCert</Arn>
          <UploadDate>2010-05-08T02:03:01.004Z</UploadDate>
          <ServerCertificateId>ASCACKCEVSQ6CEXAMPLE2</ServerCertificateId>
        </ServerCertificateMetadata>
      </member>
      <member>
        <ServerCertificateMetadata>
          <ServerCertificateName>TestServerCert</ServerCertificateName>
          <Path>/company/servercerts/</Path>
          <Arn>arn:aws:iam::123456789012:server-certificate/company/servercerts/TestServerCert</Arn>
          <UploadDate>2010-05-08T03:01:02.004Z</UploadDate>
          <ServerCertificateId>ASCACKCEVSQ6CEXAMPLE3</ServerCertificateId>
        </ServerCertificateMetadata>
      </member>
    </ServerCertificateMetadataList>
  </ListServerCertificatesResult>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</ListServerCertificatesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListServerCertificatesRequestMsg" wsa:Action="urn:ListServerCertificates"/>
      <wsdl:output message="tns:ListServerCertificatesResponseMsg" wsa:Action="urn:ListServerCertificates:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetUserPolicy">
      <wsdl:documentation><![CDATA[
    <p>Retrieves the specified policy document for the specified User. The returned policy is URL-encoded
    according to RFC 3986. For more information about RFC 3986, go to <a href="http://www.faqs.org/rfcs/rfc3986.html">http://www.faqs.org/rfcs/rfc3986.html</a>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetUserPolicy
&UserName=Bob
&PolicyName=AllAccessPolicy
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetUserPolicyResponse>
   <GetUserPolicyResult>
      <UserName>Bob</UserName>
      <PolicyName>AllAccessPolicy</PolicyName>
      <PolicyDocument>
      {"Statement":[{"Effect":"Allow","Action":"*","Resource":"*"}]}
      </PolicyDocument>
   </GetUserPolicyResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</GetUserPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetUserPolicyRequestMsg" wsa:Action="urn:GetUserPolicy"/>
      <wsdl:output message="tns:GetUserPolicyResponseMsg" wsa:Action="urn:GetUserPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateLoginProfile">
      <wsdl:documentation><![CDATA[
    <p>Updates the login profile for the specified User. Use this API to change the User's password.</p>

	<note>In the full release you will be able to use IAM to access your services through the AWS
	Management Console. Although this feature is not currently available, you can create
	login profiles for your Users now. Then, when this feature is implemented, your Users
	can use IAM to access your services through the AWS Management Console.</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateLoginProfile
&UserName=Bob
&Password=NewPassword
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateLoginProfileResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UpdateLoginProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateLoginProfileRequestMsg" wsa:Action="urn:UpdateLoginProfile"/>
      <wsdl:output message="tns:UpdateLoginProfileResponseMsg" wsa:Action="urn:UpdateLoginProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateServerCertificate">
      <wsdl:documentation><![CDATA[
    <p>Updates the name and/or the path of the specified server certificate.</p>

    <important>
    You should understand the implications of changing a server certificate's path or name. For more
    information, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/ManagingServerCerts.html" target="_blank">Managing Server Certificates</a> in <i>Using AWS Identity and Access Management</i>.
    </important>

    <note>To change a server certificate name the requester must have appropriate permissions on both
    the source object and the target object.  For example, to change the name from ProductionCert to
    ProdCert, the entity making the request must have permission on ProductionCert and ProdCert, or
    must have permission on all (*). For more information about permissions,
    see <a href="http://docs.amazonwebservices.com/IAM/2010-05-08/UserGuide/PermissionsAndPolicies.html" target="blank">Permissions and Policies</a>.
    </note>

    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateServerCertificate
&ServerCertificateName=ProdServerCert
&NewServerCertificateName=OldServerCert
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateServerCertificateResponse>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</UpdateServerCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateServerCertificateRequestMsg" wsa:Action="urn:UpdateServerCertificate"/>
      <wsdl:output message="tns:UpdateServerCertificateResponseMsg" wsa:Action="urn:UpdateServerCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateUser">
      <wsdl:documentation><![CDATA[
    <p>Updates the name and/or the path of the specified User.</p>
    
    <important>
    You should understand the implications of changing a User's path or name. For more information,
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Renaming.html" target="_blank">Renaming
     Users and Groups</a> in <i>Using AWS Identity and Access Management</i>.
    </important>

	<note>To change a User name the requester must have appropriate permissions on both the source object and
	the target object.  For example, to change Bob to Robert, the entity making the request must have permission
	on Bob and Robert, or must have permission on all (*).  For more information about permissions, see <a href="http://docs.amazonwebservices.com/IAM/2010-05-08/UserGuide/PermissionsAndPolicies.html" target="blank">Permissions and Policies</a>.
	</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateUser
&UserName=Bob
&NewUserName=Robert
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateUserResponse>
   <UpdateUserResult>
   <User>
      <Path>/division_abc/subdivision_xyz/</Path>
      <UserName>Robert</UserName>
      <UserId>AIDACKCEVSQ6C2EXAMPLE</UserId>
      <Arn>arn:aws::123456789012:user/division_abc/subdivision_xyz/Robert
      </Arn>
   </User>
   </UpdateUserResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UpdateUserResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateUserRequestMsg" wsa:Action="urn:UpdateUser"/>
      <wsdl:output message="tns:UpdateUserResponseMsg" wsa:Action="urn:UpdateUser:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteLoginProfile">
      <wsdl:documentation><![CDATA[
    <p>Deletes the login profile for the specified User, which terminates the User's ability to access AWS
       services through the IAM login page.</p>
    <important>Deleting a User's login profile does not prevent a User from accessing IAM through the
    command line interface or the API.  To prevent all User access you must also either make the access
	key inactive or delete it.  For more information about making keys inactive or deleting them, see
	<a>UpdateAccessKey</a> and <a>DeleteAccessKey</a>.
    </important>
    	<note>In the full release you will be able to use IAM to access your services through the AWS
	Management Console. Although this feature is not currently available, you can create
	login profiles for your Users now. Then, when this feature is implemented, your Users
	can use IAM to access your services through the AWS Management Console.</note>
    
    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteLoginProfile
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteLoginProfileResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteLoginProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteLoginProfileRequestMsg" wsa:Action="urn:DeleteLoginProfile"/>
      <wsdl:output message="tns:DeleteLoginProfileResponseMsg" wsa:Action="urn:DeleteLoginProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateSigningCertificate">
      <wsdl:documentation><![CDATA[
    <p>Changes the status of the specified signing certificate from active to disabled, or vice versa.
    This action can be used to disable a User's signing certificate as part of a certificate rotation
    workflow.</p>

	<p>If the <code>UserName</code> field is not specified, the UserName is determined implicitly based
	on the AWS Access Key ID used to sign the request. Because this action works for access keys under
	the AWS Account, this API can be used to manage root credentials even if the AWS Account has no associated
	Users.</p>


    <p>For information about rotating certificates, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?ManagingCredentials.html" target="_blank">Managing Keys and Certificates</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateSigningCertificate
&UserName=Bob
&CertificateId=TA7SMP42TDN5Z26OBPJE7EXAMPLE
&Status=Inactive
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateSigningCertificateResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UpdateSigningCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateSigningCertificateRequestMsg" wsa:Action="urn:UpdateSigningCertificate"/>
      <wsdl:output message="tns:UpdateSigningCertificateResponseMsg" wsa:Action="urn:UpdateSigningCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteGroupPolicy">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified policy that is associated with the specified group.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteGroupPolicy
&GroupName=Admins
&PolicyName=AdminRoot
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteGroupPolicyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteGroupPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteGroupPolicyRequestMsg" wsa:Action="urn:DeleteGroupPolicy"/>
      <wsdl:output message="tns:DeleteGroupPolicyResponseMsg" wsa:Action="urn:DeleteGroupPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListUsers">
      <wsdl:documentation><![CDATA[
    <p>Lists the Users that have the specified path prefix. If there are none, the action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListUsers
&PathPrefix=/division_abc/subdivision_xyz/product_1234/engineering/
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListUsersResponse>
   <ListUsersResult>
      <Users>
         <member>
            <Path>/division_abc/subdivision_xyz/engineering/</Path>
            <UserName>Andrew</UserName>
            <UserId>AID2MAB8DPLSRHEXAMPLE</UserId>
            <Arn>arn:aws:iam::123456789012:user
            /division_abc/subdivision_xyz/engineering/Andrew</Arn>
         </member>
         <member>
            <Path>/division_abc/subdivision_xyz/engineering/</Path>
            <UserName>Jackie</UserName>
            <UserId>AIDIODR4TAW7CSEXAMPLE</UserId>
            <Arn>arn:aws:iam::123456789012:user
            /division_abc/subdivision_xyz/engineering/Jackie</Arn>
         </member>
      </Users>
      <IsTruncated>false</IsTruncated>
   </ListUsersResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListUsersResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListUsersRequestMsg" wsa:Action="urn:ListUsers"/>
      <wsdl:output message="tns:ListUsersResponseMsg" wsa:Action="urn:ListUsers:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateGroup">
      <wsdl:documentation><![CDATA[
    <p>Updates the name and/or the path of the specified group.</p>
    
    <important>
    You should understand the implications of changing a group's path or name. For more information,
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Renaming.html" target="_blank">Renaming Users and Groups</a> in <i>Using AWS Identity and Access Management</i>.
    </important>

	<note>To change a group name the requester must have appropriate permissions on both the source object and
	the target object.  For example, to change Managers to MGRs, the entity making the request must have permission
	on Managers and MGRs, or must have permission on all (*).  For more information about permissions, see <a href="http://docs.amazonwebservices.com/IAM/2010-05-08/UserGuide/PermissionsAndPolicies.html" target="blank">Permissions and Policies</a>.
	</note>




    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateGroup
&GroupName=Test
&NewGroupName=Test_1
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateGroupResponse>
   <UpdateGroupResult>
      <Group xmlns="http://iam.amazonaws.com/doc/2010-05-08/">
         <Path>/division_abc/subdivision_xyz/product_1234/engineering/</Path>
         <GroupName>Test_1</GroupName>
         <GroupId>AGP2MAB8DPLSRHEXAMPLE</GroupId>
         <Arn>arn:aws:iam::123456789012:group/division_abc/subdivision_xyz/
         product_1234/engineering/Test_1</Arn>
      </Group>
   </UpdateGroupResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UpdateGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateGroupRequestMsg" wsa:Action="urn:UpdateGroup"/>
      <wsdl:output message="tns:UpdateGroupResponseMsg" wsa:Action="urn:UpdateGroup:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetServerCertificate">
      <wsdl:documentation><![CDATA[
    <p>Retrieves information about the specified server certificate.</p>

    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=GetServerCertificate
&ServerCertificateName=ProdServerCert
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetServerCertificateResponse>
  <GetServerCertificateResult>
    <ServerCertificate>
      <ServerCertificateMetadata>
        <ServerCertificateName>ProdServerCert</ServerCertificateName>
        <Path>/company/servercerts/</Path>
        <Arn>arn:aws:iam::123456789012:server-certificate/company/servercerts/ProdServerCert</Arn>
        <UploadDate>2010-05-08T01:02:03.004Z</UploadDate>
        <ServerCertificateId>ASCACKCEVSQ6C2EXAMPLE</ServerCertificateId>
      </ServerCertificateMetadata>
      <CertificateBody>-----BEGIN CERTIFICATE-----
MIICdzCCAeCgAwIBAgIGANc+Ha2wMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNVBAYT
AlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNBV1MxITAfBgNVBAMT
GEFXUyBMaW1pdGVkLUFzc3VyYW5jZSBDQTAeFw0wOTAyMDQxNzE5MjdaFw0xMDAy
MDQxNzE5MjdaMFIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMRcw
FQYDVQQLEw5BV1MtRGV2ZWxvcGVyczEVMBMGA1UEAxMMNTdxNDl0c3ZwYjRtMIGf
MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCpB/vsOwmT/O0td1RqzKjttSBaPjbr
dqwNe9BrOyB08fw2+Ch5oonZYXfGUrT6mkYXH5fQot9HvASrzAKHO596FdJA6DmL
ywdWe1Oggk7zFSXO1Xv+3vPrJtaYxYo3eRIp7w80PMkiOv6M0XK8ubcTouODeJbf
suDqcLnLDxwsvwIDAQABo1cwVTAOBgNVHQ8BAf8EBAMCBaAwFgYDVR0lAQH/BAww
CgYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQULGNaBphBumaKbDRK
CAi0mH8B3mowDQYJKoZIhvcNAQEFBQADgYEAuKxhkXaCLGcqDuweKtO/AEw9ZePH
wr0XqsaIK2HZboqruebXEGsojK4Ks0WzwgrEynuHJwTn760xe39rSqXWIOGrOBaX
wFpWHVjTFMKk+tSDG1lssLHyYWWdFFU4AnejRGORJYNaRHgVTKjHphc5jEhHm0BX
AEaHzTpmEXAMPLE=
-----END CERTIFICATE-----
      </CertificateBody>
    </ServerCertificate>
  </GetServerCertificateResult>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</GetServerCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetServerCertificateRequestMsg" wsa:Action="urn:GetServerCertificate"/>
      <wsdl:output message="tns:GetServerCertificateResponseMsg" wsa:Action="urn:GetServerCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="PutGroupPolicy">
      <wsdl:documentation><![CDATA[
    <p>Adds (or updates) a policy document associated with the specified group. For information about
    policies, refer to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?PoliciesOverview.html" target="_blank">Overview of Policies</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <p>For information about limits on the number of policies you can associate with a group, see
    <a href="http://docs.amazonwebservices.com/IAM/2010-05-08/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <note>Because policy documents can be large, you should use POST rather than GET when
    calling <code>PutGroupPolicy</code>. For more information,
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?IAM_UsingQueryAPI.html" target="_blank">Making Query Requests</a> in <i>Using AWS Identity and Access Management</i>.</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=PutGroupPolicy
&GroupName=Admins
&PolicyName=AdminRoot
&PolicyDocument={"Statement":[{"Effect":"Allow","Action":"*","Resource":"*"}]}
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<PutGroupPolicyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</PutGroupPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:PutGroupPolicyRequestMsg" wsa:Action="urn:PutGroupPolicy"/>
      <wsdl:output message="tns:PutGroupPolicyResponseMsg" wsa:Action="urn:PutGroupPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateUser">
      <wsdl:documentation><![CDATA[
    <p>Creates a new User for your AWS Account.</p>

    <p>For information about limitations on the number of Users you can create, see 
    <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <examples>
      <queryrequest>
      
https://iam.amazonaws.com/
?Action=CreateUser
&Path=/division_abc/subdivision_xyz/
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
</queryrequest>

      <queryresponse>
<CreateUserResponse>
   <CreateUserResult>
      <User>
         <Path>/division_abc/subdivision_xyz/</Path>
         <UserName>Bob</UserName>
         <UserId>AIDACKCEVSQ6C2EXAMPLE</UserId>
         <Arn>arn:aws:iam::123456789012:user/division_abc/subdivision_xyz/Bob
         </Arn>
     </User>
   </CreateUserResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</CreateUserResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateUserRequestMsg" wsa:Action="urn:CreateUser"/>
      <wsdl:output message="tns:CreateUserResponseMsg" wsa:Action="urn:CreateUser:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteSigningCertificate">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified signing certificate associated with the specified User.</p>

<p>If you do not specify a User name, IAM determines the User name implicitly based on the AWS
    Access Key ID signing the request. Because this action works for access keys under the AWS Account,
    you can use this API to manage root credentials even if the AWS Account has no associated Users.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteSigningCertificate
&UserName=Bob
&CertificateId=TA7SMP42TDN5Z26OBPJE7EXAMPLE
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteSigningCertificateResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteSigningCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteSigningCertificateRequestMsg" wsa:Action="urn:DeleteSigningCertificate"/>
      <wsdl:output message="tns:DeleteSigningCertificateResponseMsg" wsa:Action="urn:DeleteSigningCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="EnableMFADevice">
      <wsdl:documentation><![CDATA[
    <p>Enables the specified MFA device and associates it with the specified User name. Once enabled, the
       MFA device is required for every subsequent login by the User name associated with the device.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=EnableMFADevice
&UserName=Bob
&SerialNumber=R1234
&Code1=234567
&Code2=987654
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<EnableMFADeviceResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</EnableMFADeviceResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:EnableMFADeviceRequestMsg" wsa:Action="urn:EnableMFADevice"/>
      <wsdl:output message="tns:EnableMFADeviceResponseMsg" wsa:Action="urn:EnableMFADevice:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListUserPolicies">
      <wsdl:documentation><![CDATA[
    <p>Lists the names of the policies associated with the specified User. If there are none,
    the action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListUserPolicies
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListUserPoliciesResponse>
   <ListUserPoliciesResult>
      <PolicyNames>
         <member>AllAccessPolicy</member>
         <member>KeyPolicy</member>
      </PolicyNames>
      <IsTruncated>false</IsTruncated>
   </ListUserPoliciesResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListUserPoliciesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListUserPoliciesRequestMsg" wsa:Action="urn:ListUserPolicies"/>
      <wsdl:output message="tns:ListUserPoliciesResponseMsg" wsa:Action="urn:ListUserPolicies:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListAccessKeys">
      <wsdl:documentation><![CDATA[
    <p>Returns information about the Access Key IDs associated with the specified User. If there are none,
    the action returns an empty list.</p>

    <p>Although each User is limited to a small number of keys, you can still paginate the results
    using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>
    
	<p>If the <code>UserName</code> field is not specified, the UserName is determined implicitly based
	on the AWS Access Key ID used to sign the request. Because this action works for access keys under
	the AWS Account, this API can be used to manage root credentials even if the AWS Account has no associated Users.</p>

<note>To ensure the security of your AWS Account, the secret access key is accessible only during key and User creation.</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListAccessKeys
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListAccessKeysResponse>
   <ListAccessKeysResult>
      <UserName>Bob</UserName>
      <AccessKeyMetadata>
         <member>
            <UserName>Bob</UserName>
            <AccessKeyId>AKIAIOSFODNN7EXAMPLE</AccessKeyId>
            <Status>Active</Status>
         </member>
         <member>
            <UserName>Bob</UserName>
            <AccessKeyId>AKIAI44QH8DHBEXAMPLE</AccessKeyId>
            <Status>Inactive</Status>
         </member>
      </AccessKeyMetadata>
      <IsTruncated>false</IsTruncated>
   </ListAccessKeysResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListAccessKeysResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListAccessKeysRequestMsg" wsa:Action="urn:ListAccessKeys"/>
      <wsdl:output message="tns:ListAccessKeysResponseMsg" wsa:Action="urn:ListAccessKeys:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetLoginProfile">
      <wsdl:documentation><![CDATA[
    <p>Retrieves the login profile for the specified User.</p>

	<note>In the full release you will be able to use IAM to access your services through the AWS
	Management Console. Although this feature is not currently available, you can create
	login profiles for your Users now. Then, when this feature is implemented, your Users
	can use IAM to access your services through the AWS Management Console.</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetLoginProfile
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetLoginProfileResponse>
   <GetLoginProfileResult>
      <LoginProfile>
         <UserName>Bob</UserName>
      </LoginProfile>
   </GetLoginProfileResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</GetLoginProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetLoginProfileRequestMsg" wsa:Action="urn:GetLoginProfile"/>
      <wsdl:output message="tns:GetLoginProfileResponseMsg" wsa:Action="urn:GetLoginProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListGroupsForUser">
      <wsdl:documentation><![CDATA[
    <p>Lists the groups the specified User belongs to.</p>
     
    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest> 
https://iam.amazonaws.com/
?Action=ListGroupsForUser
&UserName=Bob
&AUTHPARAMS
       </queryrequest>

      <queryresponse> 
<ListGroupsForUserResponse> 
   <ListGroupsForUserResult>
      <Groups>
         <member>
            <Path>/</Path>
            <GroupName>Admins</GroupName>
            <GroupId>AGPACKCEVSQ6C2EXAMPLE</GroupId>
            <Arn>arn:aws:iam::123456789012:group/Admins</Arn>
         </member>
      </Groups>
      <IsTruncated>false</IsTruncated>
   </ListGroupsForUserResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListGroupsForUserResponse>
</queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListGroupsForUserRequestMsg" wsa:Action="urn:ListGroupsForUser"/>
      <wsdl:output message="tns:ListGroupsForUserResponseMsg" wsa:Action="urn:ListGroupsForUser:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateGroup">
      <wsdl:documentation><![CDATA[
    <p>Creates a new group.</p>

    <p>For information about the number of groups you can create, 
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=CreateGroup
&Path=/
&GroupName=Admins
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<CreateGroupResponse>
   <CreateGroupResult>
      <Group>
         <Path>/</Path>
         <GroupName>Admins</GroupName>
         <GroupId>AGPACKCEVSQ6C2EXAMPLE</GroupId>
         <Arn>arn:aws:iam::123456789012:group/Admins</Arn>
      </Group>
   </CreateGroupResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</CreateGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateGroupRequestMsg" wsa:Action="urn:CreateGroup"/>
      <wsdl:output message="tns:CreateGroupResponseMsg" wsa:Action="urn:CreateGroup:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UploadServerCertificate">
      <wsdl:documentation><![CDATA[
    <p>Uploads a server certificate entity for the AWS Account. The server certificate entity includes a
    public key certificate, a private key, and an optional certificate chain, which should all be PEM-encoded.</p>

    <p>For information about the number of server certificates you can upload, see 
    <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <note>Because the body of the public key certificate, private key, and the certificate chain can be large,
    you should use POST rather than GET when calling <code>UploadServerCertificate</code>. For more information,
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/IAM_UsingQueryAPI.html" target="_blank">
    Making Query Requests</a> in <i>Using AWS Identity and Access Management</i>.</note>

    <examples>
          <queryrequest>
https://iam.amazonaws.com/
?Action=UploadServerCertificate
&ServerCertificateName=ProdServerCert
&Path=/company/servercerts/
&CertificateBody=-----BEGIN CERTIFICATE-----
MIICdzCCAeCgAwIBAgIGANc+Ha2wMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNVBAYT
AlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNBV1MxITAfBgNVBAMT
GEFXUyBMaW1pdGVkLUFzc3VyYW5jZSBDQTAeFw0wOTAyMDQxNzE5MjdaFw0xMDAy
MDQxNzE5MjdaMFIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMRcw
FQYDVQQLEw5BV1MtRGV2ZWxvcGVyczEVMBMGA1UEAxMMNTdxNDl0c3ZwYjRtMIGf
MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCpB/vsOwmT/O0td1RqzKjttSBaPjbr
dqwNe9BrOyB08fw2+Ch5oonZYXfGUrT6mkYXH5fQot9HvASrzAKHO596FdJA6DmL
ywdWe1Oggk7zFSXO1Xv+3vPrJtaYxYo3eRIp7w80PMkiOv6M0XK8ubcTouODeJbf
suDqcLnLDxwsvwIDAQABo1cwVTAOBgNVHQ8BAf8EBAMCBaAwFgYDVR0lAQH/BAww
CgYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQULGNaBphBumaKbDRK
CAi0mH8B3mowDQYJKoZIhvcNAQEFBQADgYEAuKxhkXaCLGcqDuweKtO/AEw9ZePH
wr0XqsaIK2HZboqruebXEGsojK4Ks0WzwgrEynuHJwTn760xe39rSqXWIOGrOBaX
wFpWHVjTFMKk+tSDG1lssLHyYWWdFFU4AnejRGORJYNaRHgVTKjHphc5jEhHm0BX
AEaHzTpmEXAMPLE=
-----END CERTIFICATE-----
&PrivateKey=-----BEGIN DSA PRIVATE KEY-----
MIIBugIBTTKBgQD33xToSXPJ6hr37L3+KNi3/7DgywlBcvlFPPSHIw3ORuO/22mT
8Cy5fT89WwNvZ3BPKWU6OZ38TQv3eWjNc/3U3+oqVNG2poX5nCPOtO1b96HYX2mR
3FTdH6FRKbQEhpDzZ6tRrjTHjMX6sT3JRWkBd2c4bGu+HUHO1H7QvrCTeQIVTKMs
TCKCyrLiGhUWuUGNJUMU6y6zToGTHl84Tz7TPwDGDXuy/Dk5s4jTVr+xibROC/gS
Qrs4Dzz3T1ze6lvU8S1KT9UsOB5FUJNTTPCPey+Lo4mmK6b23XdTyCIT8e2fsm2j
jHHC1pIPiTkdLS3j6ZYjF8LY6TENFng+LDY/xwPOl7TJVoD3J/WXC2J9CEYq9o34
kq6WWn3CgYTuo54nXUgnoCb3xdG8COFrg+oTbIkHTSzs3w5o/GGgKK7TDF3UlJjq
vHNyJQ6kWBrQRR1Xp5KYQ4c/Dm5kef+62mH53HpcCELguWVcffuVQpmq3EWL9Zp9
jobTJQ2VHjb5IVxiO6HRSd27di3njyrzUuJCyHSDTqwLJmTThpd6OTIUTL3Tc4m2
62TITdw53KWJEXAMPLE=
-----END DSA PRIVATE KEY-----
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UploadServerCertificateResponse>
  <UploadServerCertificateResult>
    <ServerCertificateMetadata>
      <ServerCertificateName>ProdServerCert</ServerCertificateName>
      <Path>/company/servercerts/</Path>
      <Arn>arn:aws:iam::123456789012:server-certificate/company/servercerts/ProdServerCert</Arn>
      <UploadDate>2010-05-08T01:02:03.004Z</UploadDate>
      <ServerCertificateId>ASCACKCEVSQ6C2EXAMPLE</ServerCertificateId>
    </ServerCertificateMetadata>
  </UploadServerCertificateResult>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</UploadServerCertificateResponse>
      </queryresponse>

    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UploadServerCertificateRequestMsg" wsa:Action="urn:UploadServerCertificate"/>
      <wsdl:output message="tns:UploadServerCertificateResponseMsg" wsa:Action="urn:UploadServerCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetGroupPolicy">
      <wsdl:documentation><![CDATA[
    <p>Retrieves the specified policy document for the specified group. The returned policy is URL-encoded
    according to RFC 3986. For more information about RFC 3986, go to <a href="http://www.faqs.org/rfcs/rfc3986.html">http://www.faqs.org/rfcs/rfc3986.html</a>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetGroupPolicy
&GroupName=Admins
&PolicyName=AdminRoot
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetGroupPolicyResponse>
   <GetGroupPolicyResult>
      <GroupName>Admins</GroupName>
      <PolicyName>AdminRoot</PolicyName>
      <PolicyDocument>
      {"Statement":[{"Effect":"Allow","Action":"*","Resource":"*"}]}
      </PolicyDocument>
   </GetGroupPolicyResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</GetGroupPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetGroupPolicyRequestMsg" wsa:Action="urn:GetGroupPolicy"/>
      <wsdl:output message="tns:GetGroupPolicyResponseMsg" wsa:Action="urn:GetGroupPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteUser">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified User. The User must not belong to any groups, have any keys or
    signing certificates, or have any attached policies.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteUser
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteUserResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteUserResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteUserRequestMsg" wsa:Action="urn:DeleteUser"/>
      <wsdl:output message="tns:DeleteUserResponseMsg" wsa:Action="urn:DeleteUser:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeactivateMFADevice">
      <wsdl:documentation><![CDATA[
    <p>Deactivates the specified MFA device and removes it from association with the
	User name for which it was originally enabled.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeactivateMFADevice
&UserName=Bob
&SerialNumber=R1234
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeactivateMFADeviceResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeactivateMFADeviceResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeactivateMFADeviceRequestMsg" wsa:Action="urn:DeactivateMFADevice"/>
      <wsdl:output message="tns:DeactivateMFADeviceResponseMsg" wsa:Action="urn:DeactivateMFADevice:Response"/>
    </wsdl:operation>

    <wsdl:operation name="RemoveUserFromGroup">
      <wsdl:documentation><![CDATA[
    <p>Removes the specified User from the specified group.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=RemoveUserFromGroup
&GroupName=Managers
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<RemoveUserFromGroupResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</RemoveUserFromGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:RemoveUserFromGroupRequestMsg" wsa:Action="urn:RemoveUserFromGroup"/>
      <wsdl:output message="tns:RemoveUserFromGroupResponseMsg" wsa:Action="urn:RemoveUserFromGroup:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteServerCertificate">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified server certificate.</p>

    <important>If your Elastic Load Balancing instances are using a server certificate, deleting 
    the certificate could have implications for your application. If your Elastic Load Balancing instances 
    do not detect the deletion of bound certificates, they may continue to use the certificates.  This could
    cause them to stop accepting traffic.  We recommend that you remove the reference to the certificate from
    your Elastic Load Balancing instances before using this command to delete the certificate.</important>

    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteServerCertificate
&ServerCertificateName=ProdServerCert
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteServerCertificateResponse>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</DeleteServerCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteServerCertificateRequestMsg" wsa:Action="urn:DeleteServerCertificate"/>
      <wsdl:output message="tns:DeleteServerCertificateResponseMsg" wsa:Action="urn:DeleteServerCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListGroupPolicies">
      <wsdl:documentation><![CDATA[
    <p>Lists the names of the policies associated with the specified group. If there are none,
    the action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListGroupPolicies
&GroupName=Admins
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListGroupPoliciesResponse>
   <ListGroupPoliciesResult>
      <PolicyNames>
         <member>AdminRoot</member>
         <member>KeyPolicy</member>
      </PolicyNames>
      <IsTruncated>false</IsTruncated>
   </ListGroupPoliciesResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListGroupPoliciesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListGroupPoliciesRequestMsg" wsa:Action="urn:ListGroupPolicies"/>
      <wsdl:output message="tns:ListGroupPoliciesResponseMsg" wsa:Action="urn:ListGroupPolicies:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateLoginProfile">
      <wsdl:documentation><![CDATA[
    <p>Creates a login profile for the specified User, giving the User the ability to access AWS services
       such as the AWS Management Console.  For more information about login profiles, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_ManagingLoginsAndMFA.html" target="_blank">Managing Login Profiles and MFA Devices</a> in <i>Using AWS Identity and Access Management</i>.</p>

	<note>In the full release you will be able to use IAM to access your services through the AWS
	Management Console. Although this feature is not currently available, you can create
	login profiles for your Users now. Then, when this feature is implemented, your Users
	can use IAM to access your services through the AWS Management Console.</note>
	
    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=CreateLoginProfile
&UserName=Bob
&Password=Password1
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<CreateLoginProfileResponse>
   <CreateUserResult>
      <LoginProfile>
         <UserName>Bob</UserName>
      </LoginProfile>
   </CreateUserResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</CreateLoginProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateLoginProfileRequestMsg" wsa:Action="urn:CreateLoginProfile"/>
      <wsdl:output message="tns:CreateLoginProfileResponseMsg" wsa:Action="urn:CreateLoginProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateAccessKey">
      <wsdl:documentation><![CDATA[
    <p>Creates a new AWS Secret Access Key and corresponding AWS Access Key ID for the specified User. The default
	status for new keys is <code>Active</code>.</p>

	<p>If you do not specify a User name, IAM determines the User name implicitly based on the AWS
    Access Key ID signing the request. Because this action works for access keys under the AWS Account,
    you can use this API to manage root credentials even if the AWS Account has no associated Users.</p>

    <p>For information about limits on the number of keys you can create, see <a href="http://docs.amazonwebservices.com/IAM/2010-05-08/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
    
    <important>To ensure the security of your AWS Account, the Secret Access Key is accessible
					only during key and User creation.  You must save the key (for example, in a text
					file) if you want to be able to access it again.  If a secret key is lost, you
					can delete the access keys for the associated User and then create new keys.</important>
    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=CreateAccessKey
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<CreateAccessKeyResponse>
   <CreateAccessKeyResult>
     <AccessKey>
         <UserName>Bob</UserName>
         <AccessKeyId>AKIAIOSFODNN7EXAMPLE</AccessKeyId>
         <Status>Active</Status>
         <SecretAccessKey>wJalrXUtnFEMI/K7MDENG/bPxRfiCYzEXAMPLEKEY
         </SecretAccessKey>
      </AccessKey>
   </CreateAccessKeyResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</CreateAccessKeyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateAccessKeyRequestMsg" wsa:Action="urn:CreateAccessKey"/>
      <wsdl:output message="tns:CreateAccessKeyResponseMsg" wsa:Action="urn:CreateAccessKey:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetUser">
      <wsdl:documentation><![CDATA[
    <p>Retrieves information about the specified User, including the User's path, GUID, and ARN.</p>

    <p>If you do not specify a User name, IAM determines the User name implicitly based on the AWS
    Access Key ID signing the request.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetUser
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetUserResponse>
   <GetUserResult>
      <User>
         <Path>/division_abc/subdivision_xyz/</Path>
         <UserName>Bob</UserName>
         <UserId>AIDACKCEVSQ6C2EXAMPLE</UserId>
         <Arn>
         arn:aws:iam::123456789012:user/division_abc/subdivision_xyz/Bob
         </Arn>
      </User>
   </GetUserResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</GetUserResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetUserRequestMsg" wsa:Action="urn:GetUser"/>
      <wsdl:output message="tns:GetUserResponseMsg" wsa:Action="urn:GetUser:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ResyncMFADevice">
      <wsdl:documentation><![CDATA[
    <p>Synchronizes the specified MFA device with AWS servers.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ResyncMFADevice
&UserName=Bob
&SerialNumber=R1234
&Code1=234567
&Code2=987654
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ResyncMFADeviceResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ResyncMFADeviceResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ResyncMFADeviceRequestMsg" wsa:Action="urn:ResyncMFADevice"/>
      <wsdl:output message="tns:ResyncMFADeviceResponseMsg" wsa:Action="urn:ResyncMFADevice:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListMFADevices">
      <wsdl:documentation><![CDATA[
    <p>Lists the MFA devices associated with the specified User name.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListMFADevices
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListMFADevicesResponse>
   <ListMFADevicesResult>
      <MFADevices>
         <member>
            <UserName>Bob</UserName>
            <SerialNumber>R1234</SerialNumber>
         </member>
      </MFADevices>
      <IsTruncated>false</IsTruncated>
   </ListMFADevicesResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListMFADevicesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListMFADevicesRequestMsg" wsa:Action="urn:ListMFADevices"/>
      <wsdl:output message="tns:ListMFADevicesResponseMsg" wsa:Action="urn:ListMFADevices:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateAccessKey">
      <wsdl:documentation><![CDATA[
    <p>Changes the status of the specified access key from Active to Inactive, or vice versa.
    This action can be used to disable a User's key as part of a key rotation workflow.</p>
    
	<p>If the <code>UserName</code> field is not specified, the UserName is determined implicitly
	based on the AWS Access Key ID used to sign the request. Because this action works for access
	keys under the AWS Account, this API can be used to manage root credentials even if the AWS Account
	has no associated Users.</p>

    <p>For information about rotating keys, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?ManagingCredentials.html" target="_blank">Managing Keys and Certificates</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateAccessKey
&UserName=Bob
&AccessKeyId=AKIAIOSFODNN7EXAMPLE
&Status=Inactive
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateAccessKeyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UpdateAccessKeyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateAccessKeyRequestMsg" wsa:Action="urn:UpdateAccessKey"/>
      <wsdl:output message="tns:UpdateAccessKeyResponseMsg" wsa:Action="urn:UpdateAccessKey:Response"/>
    </wsdl:operation>

    <wsdl:operation name="AddUserToGroup">
      <wsdl:documentation><![CDATA[
    <p>Adds the specified User to the specified group.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=AddUserToGroup
&GroupName=Managers
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<AddUserToGroupResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</AddUserToGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:AddUserToGroupRequestMsg" wsa:Action="urn:AddUserToGroup"/>
      <wsdl:output message="tns:AddUserToGroupResponseMsg" wsa:Action="urn:AddUserToGroup:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetGroup">
      <wsdl:documentation><![CDATA[
    <p>Returns a list of Users that are in the specified group. You can paginate the results using the <code>MaxItems</code> 
    and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetGroup
&GroupName=Admins
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetGroupResponse>
   <GetGroupResult>
      <Group>
         <Path>/</Path>
         <GroupName>Admins</GroupName>
         <GroupId>AGPACKCEVSQ6C2EXAMPLE</GroupId>
         <Arn>arn:aws:iam::123456789012:group/Admins</Arn>
      </Group>
      <Users>      
         <member>
            <Path>/division_abc/subdivision_xyz/</Path>
            <UserName>Bob</UserName>
            <UserId>AIDACKCEVSQ6C2EXAMPLE</UserId>
            <Arn>
            arn:aws:iam::123456789012:user/division_abc/subdivision_xyz/Bob
            </Arn>
         </member>
         <member>
            <Path>/division_abc/subdivision_xyz/</Path>
            <UserName>Susan</UserName>
            <UserId>AIDACKCEVSQ6C2EXAMPLE</UserId>
            <Arn>
            arn:aws:iam::123456789012:user/division_abc/subdivision_xyz/Susan
            </Arn>
         </member>
      </Users>
      <IsTruncated>false</IsTruncated>
   </GetGroupResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</GetGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetGroupRequestMsg" wsa:Action="urn:GetGroup"/>
      <wsdl:output message="tns:GetGroupResponseMsg" wsa:Action="urn:GetGroup:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteGroup">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified group. The group must not contain any Users or have any attached policies.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteGroup
&Group=Test
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteGroupResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteGroupRequestMsg" wsa:Action="urn:DeleteGroup"/>
      <wsdl:output message="tns:DeleteGroupResponseMsg" wsa:Action="urn:DeleteGroup:Response"/>
    </wsdl:operation>

  </wsdl:portType>

  <wsdl:binding name="AWSIdentityManagementV20100508Binding" type="tns:AWSIdentityManagementV20100508PortType">

    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>

    <wsdl:operation name="ListGroups">
      <soap:operation soapAction="ListGroups"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteAccessKey">
      <soap:operation soapAction="DeleteAccessKey"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListSigningCertificates">
      <soap:operation soapAction="ListSigningCertificates"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UploadSigningCertificate">
      <soap:operation soapAction="UploadSigningCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteUserPolicy">
      <soap:operation soapAction="DeleteUserPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="PutUserPolicy">
      <soap:operation soapAction="PutUserPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListServerCertificates">
      <soap:operation soapAction="ListServerCertificates"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetUserPolicy">
      <soap:operation soapAction="GetUserPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateLoginProfile">
      <soap:operation soapAction="UpdateLoginProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateServerCertificate">
      <soap:operation soapAction="UpdateServerCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateUser">
      <soap:operation soapAction="UpdateUser"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteLoginProfile">
      <soap:operation soapAction="DeleteLoginProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateSigningCertificate">
      <soap:operation soapAction="UpdateSigningCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteGroupPolicy">
      <soap:operation soapAction="DeleteGroupPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListUsers">
      <soap:operation soapAction="ListUsers"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateGroup">
      <soap:operation soapAction="UpdateGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetServerCertificate">
      <soap:operation soapAction="GetServerCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="PutGroupPolicy">
      <soap:operation soapAction="PutGroupPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateUser">
      <soap:operation soapAction="CreateUser"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteSigningCertificate">
      <soap:operation soapAction="DeleteSigningCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="EnableMFADevice">
      <soap:operation soapAction="EnableMFADevice"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListUserPolicies">
      <soap:operation soapAction="ListUserPolicies"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListAccessKeys">
      <soap:operation soapAction="ListAccessKeys"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetLoginProfile">
      <soap:operation soapAction="GetLoginProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListGroupsForUser">
      <soap:operation soapAction="ListGroupsForUser"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateGroup">
      <soap:operation soapAction="CreateGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UploadServerCertificate">
      <soap:operation soapAction="UploadServerCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetGroupPolicy">
      <soap:operation soapAction="GetGroupPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteUser">
      <soap:operation soapAction="DeleteUser"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeactivateMFADevice">
      <soap:operation soapAction="DeactivateMFADevice"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="RemoveUserFromGroup">
      <soap:operation soapAction="RemoveUserFromGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteServerCertificate">
      <soap:operation soapAction="DeleteServerCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListGroupPolicies">
      <soap:operation soapAction="ListGroupPolicies"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateLoginProfile">
      <soap:operation soapAction="CreateLoginProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateAccessKey">
      <soap:operation soapAction="CreateAccessKey"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetUser">
      <soap:operation soapAction="GetUser"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ResyncMFADevice">
      <soap:operation soapAction="ResyncMFADevice"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListMFADevices">
      <soap:operation soapAction="ListMFADevices"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateAccessKey">
      <soap:operation soapAction="UpdateAccessKey"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="AddUserToGroup">
      <soap:operation soapAction="AddUserToGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetGroup">
      <soap:operation soapAction="GetGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteGroup">
      <soap:operation soapAction="DeleteGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

  </wsdl:binding>

  <wsdl:service name="AWSIdentityManagementV20100508">
    <wsdl:documentation><![CDATA[
    <fullname>AWS Identity and Access Management</fullname>
    
    <p>AWS Identity and Access Management (IAM) is a web service that enables Amazon Web 
    Services (AWS) customers to manage Users and User permissions under their AWS Account.</p> 
    
	<p>This is the AWS Identity and Access Management API Reference. This guide describes who should read this
		guide and other resources related to IAM.</p>    
    
    <p>Use of this guide assumes you are familiar with the following:</p>
    <ul><li>Basic understanding of web services (for information, go to W3 Schools Web Services Tutorial at <a href="http://www.w3schools.com/webservices/default.asp" target="_blank">http://www.w3schools.com/webservices/default.asp</a>).</li>
        <li>XML (for information, go to W3 Schools XML Tutorial at <a href="http://www.w3schools.com/xml/default.asp" target="_blank">http://www.w3schools.com/xml/default.asp</a>).</li>
        <li>JSON (for information, go to <a href="http://json.org" target="_blank">http://json.org</a>)</li>
        <li>The specific AWS products you are using or plan to use (e.g., Amazon Elastic Compute Cloud (Amazon EC2), Amazon Simple Storage Service (Amazon S3), and so on.)</li>
        </ul>
        <p>If you're new to AWS and need additional technical information about a specific AWS product, you can find the product's
technical documentation at <a href="http://aws.amazon.com/documentation/" target="_blank">http://aws.amazon.com/documentation/</a>.</p>
    
    <p>We will refer to Amazon AWS Identity and Access Management using the abbreviated
		form IAM. All copyrights and legal protections still apply.</p>
		
 ]]></wsdl:documentation>
    <wsdl:port name="AWSIdentityManagementV20100508Port" binding="tns:AWSIdentityManagementV20100508Binding">
      <soap:address location="https://iam.amazonaws.com"/>
    </wsdl:port>
  </wsdl:service>

</wsdl:definitions>