diff --git a/clc/modules/cluster-manager/src/main/java/com/eucalyptus/cluster/callback/VmStateCallback.java b/clc/modules/cluster-manager/src/main/java/com/eucalyptus/cluster/callback/VmStateCallback.java
index 53ce8a6..e6eb660 100644
--- a/clc/modules/cluster-manager/src/main/java/com/eucalyptus/cluster/callback/VmStateCallback.java
+++ b/clc/modules/cluster-manager/src/main/java/com/eucalyptus/cluster/callback/VmStateCallback.java
@@ -62,17 +62,28 @@
 
 package com.eucalyptus.cluster.callback;
 
-import java.util.Collection;
-import java.util.Collections;
+import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Set;
-import java.util.concurrent.CancellationException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.Executors;
 import javax.annotation.Nullable;
 import javax.persistence.EntityTransaction;
+
+import com.eucalyptus.component.id.ClusterController;
+import com.eucalyptus.entities.TransactionResource;
+import com.eucalyptus.system.Threads;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import org.apache.log4j.Logger;
+import org.hibernate.Criteria;
+import org.hibernate.criterion.Criterion;
+import org.hibernate.criterion.Example;
+import org.hibernate.criterion.Projections;
 import org.hibernate.criterion.Restrictions;
 import com.eucalyptus.bootstrap.Databases;
-import com.eucalyptus.compute.common.CloudMetadatas;
 import com.eucalyptus.cluster.Cluster;
 import com.eucalyptus.compute.common.network.InstanceResourceReportType;
 import com.eucalyptus.compute.common.network.Networking;
@@ -97,7 +108,6 @@ import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
-import com.google.common.collect.Collections2;
 import com.google.common.collect.Sets;
 import edu.ucsb.eucalyptus.cloud.VmDescribeResponseType;
 import edu.ucsb.eucalyptus.cloud.VmDescribeType;
@@ -107,52 +117,138 @@ import edu.ucsb.eucalyptus.msgs.VmTypeInfo;
 public class VmStateCallback extends StateUpdateMessageCallback<Cluster, VmDescribeType, VmDescribeResponseType> {
   private static Logger LOG = Logger.getLogger( VmStateCallback.class );
   private final Supplier<Set<String>> initialInstances;
+  private static List<VmState> activeStates = Lists.newArrayList(
+      VmState.PENDING,
+      VmState.RUNNING,
+      VmState.SHUTTING_DOWN,
+      VmState.STOPPING
+  );
 
   public VmStateCallback() {
-    super( new VmDescribeType( ) {
+    super(
+        new VmDescribeType() {
           {
             regarding();
           }
-    } );
-    this.initialInstances = createInstanceSupplier( this, partitionFilter( this ) );
+        }
+    );
+    this.initialInstances = createInstanceSupplier(
+        this,
+        Restrictions.in( "state", activeStates ),
+        Restrictions.isNotNull( "runtimeState.serviceTag" )
+    );
   }
 
-  private static Supplier<Set<String>> createInstanceSupplier( final StateUpdateMessageCallback<Cluster, ?, ?> cb, final Predicate<VmInstance> filter ) {
-    return Suppliers.memoize( new Supplier<Set<String>>( ) {
+  private static Supplier<Set<String>> createInstanceSupplier(
+      final StateUpdateMessageCallback<Cluster, ?, ?> cb,
+      final Criterion... criteria
+  ) {
+    return Suppliers.memoize(
+        new Supplier<Set<String>>() {
 
           @Override
           public Set<String> get() {
-        final EntityTransaction db = Entities.get( VmInstance.class );
-        try {
-          Collection<VmInstance> clusterInstances =  VmInstances.list( null, Restrictions.conjunction( ), Collections.<String,String>emptyMap( ), filter );
-          Collection<String> instanceNames = Collections2.transform( clusterInstances, CloudMetadatas.toDisplayName( ) );
-          return Sets.newHashSet( instanceNames );
-        } catch ( Exception ex ) {
-          Logs.extreme( ).error( ex, ex );
-          return Sets.newHashSet( );
-        } finally {
-          db.rollback();
-        }
-      }
-    } );
+            try ( final TransactionResource db = Entities.transactionFor( VmInstance.class ) ) {
+              final Criteria query = Entities.createCriteria( VmInstance.class )
+                                             .add( Example.create( VmInstance.named( null, null ) ) )
+                                             .setReadOnly( true )
+                                             .setCacheable( false )
+                                             .setFetchSize( 100000 )
+                                             .add(
+                                                 Restrictions.eq(
+                                                     "placement.partitionName",
+                                                     cb.getSubject().getConfiguration().getPartition()
+                                                 )
+                                             )
+                                             .setProjection( Projections.property( "displayName" ) );
+              for ( Criterion c : criteria ) {
+                query.add( c );
+              }
+              Set<String> result = Sets.<String>newHashSet( query.list() );
+              db.commit();
+              return result;
+            }
+          }
+        }
+    );
   }
 
-  /**
-   * @see com.eucalyptus.cluster.callback.StateUpdateMessageCallback#fireException(com.eucalyptus.util.async.FailedRequestException)
-   * @param t
-   */
   @Override
   public void fireException( FailedRequestException t ) {
     LOG.debug( "Request to " + this.getSubject().getName() + " failed: " + t.getMessage() );
   }
 
+  private static ConcurrentMap<String, Callable<Object>> pendingUpdates = Maps.newConcurrentMap();
+
+  enum UpdateTaskFunction implements Function<VmInfo, Runnable> {
+    UPDATE {
+      void task( VmInfo runVm ) {
+        VmStateCallback.handleReportedState( runVm );
+      }
+    },
+    RESTORE {
+      @Override
+      void task( VmInfo runVm ) {
+        VmStateCallback.handleRestore( runVm );
+      }
+    },
+    UNREPORTED {
+      @Override
+      void task( VmInfo runVm ) {
+        VmStateCallback.handleUnreported( runVm.getInstanceId() );
+      }
+    };
+    private static final Runnable noop = new Runnable() {
+      @Override
+      public void run() {
+
+      }
+    };
+
+    abstract void task( VmInfo runVm );
+
+    @Override
+    public Runnable apply( final VmInfo input ) {
+      try {
+        Runnable run = new Runnable() {
+          @Override
+          public void run() {
+            try {
+              UpdateTaskFunction.this.task( input );
+            } catch ( Exception e ) {
+              LOG.error(
+                  "Failed to "
+                  + UpdateTaskFunction.this.name().toLowerCase()
+                  + " instance: "
+                  + input.getInstanceId()
+                  + " because of "
+                  + e.getMessage()
+              );
+            } finally {
+              pendingUpdates.remove( input.getInstanceId() );
+            }
+          }
+        };
+        if ( input != null
+             && input.getInstanceId() != null
+             && pendingUpdates.putIfAbsent( input.getInstanceId(), Executors.callable( run ) ) == null ) {
+          return run;
+        } else {
+          return noop;
+        }
+      } catch ( Exception e ) {
+        return noop;
+      }
+    }
+  }
+
   @Override
   public void fire( VmDescribeResponseType reply ) {
     UpdateInstanceResourcesType update = new UpdateInstanceResourcesType();
     update.setPartition( this.getSubject().getPartition() );
     update.setResources( TypeMappers.transform( reply, InstanceResourceReportType.class ) );
     Networking.getInstance().update( update );
-
+    List<Runnable> taskList = Lists.newArrayList();
     if ( Databases.isVolatile() ) {
       return;
     } else {
@@ -164,30 +260,53 @@ public class VmStateCallback extends StateUpdateMessageCallback<Cluster, VmDescr
         VmTypeInfo typeInfo = vmInfo.getInstanceType();
         if ( typeInfo.getName() == null || "".equals( typeInfo.getName() ) ) {
           for ( VmType t : VmTypes.list() ) {
-            if ( t.getCpu( ).equals( typeInfo.getCores( ) ) && t.getDisk( ).equals( typeInfo.getDisk( ) ) && t.getMemory( ).equals( typeInfo.getMemory( ) ) ) {
+            if ( t.getCpu().equals( typeInfo.getCores() ) && t.getDisk().equals( typeInfo.getDisk() ) &&
+                 t.getMemory().equals( typeInfo.getMemory() ) ) {
               typeInfo.setName( t.getName() );
             }
           }
         }
       }
 
-      final Set<String> unreportedInstances = Sets.newHashSet( Sets.difference( this.initialInstances.get( ), reportedInstances ) );
-      final Set<String> restoreInstances = Sets.newHashSet( Sets.difference( reportedInstances, this.initialInstances.get( ) ) );
+      final Set<String> unreportedInstances =
+          Sets.newHashSet( Sets.difference( this.initialInstances.get(), reportedInstances ) );
+      final Set<String> restoreInstances =
+          Sets.newHashSet( Sets.difference( reportedInstances, this.initialInstances.get() ) );
       for ( final VmInfo runVm : reply.getVms() ) {
         if ( Databases.isVolatile() ) {
           return;
         } else if ( this.initialInstances.get().contains( runVm.getInstanceId() ) ) {
-          VmStateCallback.handleReportedState( runVm );
+          taskList.add( UpdateTaskFunction.UPDATE.apply( runVm ) );
         } else if ( restoreInstances.contains( runVm.getInstanceId() ) ) {
-          VmStateCallback.handleRestore( runVm );
+          taskList.add( UpdateTaskFunction.RESTORE.apply( runVm ) );
         }
       }
       for ( final String vmId : unreportedInstances ) {
         if ( Databases.isVolatile() ) {
           return;
         } else {
-          VmStateCallback.handleUnreported( vmId );
+          taskList.add(
+              UpdateTaskFunction.UNREPORTED.apply(
+                  new VmInfo() {
+                    {
+                      this.setInstanceId( vmId );
+                    }
                   }
+              )
+          );
+        }
+      }
+      for ( final Runnable c : Iterables.filter(
+          taskList, Predicates.not(
+              Predicates.equalTo( UpdateTaskFunction.noop )
+          )
+      ) ) {
+        Threads.enqueue(
+            ClusterController.class,
+            VmStateCallback.class,
+            ( Runtime.getRuntime().availableProcessors() * 2 ) + 1,
+            Executors.callable( c )
+        );
       }
     }
   }
@@ -263,7 +382,7 @@ public class VmStateCallback extends StateUpdateMessageCallback<Cluster, VmDescr
         Logs.extreme().error( ex, ex );
         throw ex;
       } finally {
-        if ( db.isActive() ) db.rollback();
+        if ( db.isActive() ) { db.rollback(); }
       }
     } catch ( TerminatedInstanceException ex1 ) {
       LOG.trace( "Ignore state update to terminated instance: " + runVm.getInstanceId() );
@@ -344,23 +463,34 @@ public class VmStateCallback extends StateUpdateMessageCallback<Cluster, VmDescr
     };
   }
 
-  public static class VmPendingCallback extends StateUpdateMessageCallback<Cluster, VmDescribeType, VmDescribeResponseType> {
+  public static class VmPendingCallback extends StateUpdateMessageCallback<Cluster, VmDescribeType,
+      VmDescribeResponseType> {
     @SuppressWarnings( "unchecked" )
-    private final Predicate<VmInstance> filter = Predicates.and( VmStateSet.TORNDOWN.not( ), stateSettleFilter( ), partitionFilter( this ) );
+    private final Predicate<VmInstance> filter =
+        Predicates.alwaysTrue();
     private final Supplier<Set<String>> initialInstances;
 
     public VmPendingCallback( Cluster cluster ) {
       super( cluster );
-      this.initialInstances = createInstanceSupplier( this, this.filter );
-      this.setRequest( new VmDescribeType( ) {
+      this.initialInstances = createInstanceSupplier(
+          this,
+          Restrictions.not(
+              Restrictions.in(
+                  "state",
+                  new VmState[]{ VmState.RUNNING,
+                      VmState.TERMINATED,
+                      VmState.BURIED,
+                      VmState.STOPPED }
+              )
+          )
+      );
+      this.setRequest(
+          new VmDescribeType() {
             {
               regarding();
-          this.getInstancesSet( ).addAll( VmPendingCallback.this.initialInstances.get( ) );
             }
-      } );
-      if ( this.getRequest( ).getInstancesSet( ).isEmpty( ) ) {
-        throw new CancellationException( );
           }
+      );
     }
 
     @Override
@@ -374,10 +504,6 @@ public class VmStateCallback extends StateUpdateMessageCallback<Cluster, VmDescr
       }
     }
 
-    /**
-     * @see com.eucalyptus.cluster.callback.StateUpdateMessageCallback#fireException(com.eucalyptus.util.async.FailedRequestException)
-     * @param t
-     */
     @Override
     public void fireException( FailedRequestException t ) {
       LOG.debug( "Request to " + this.getSubject().getName() + " failed: " + t.getMessage() );
@@ -392,7 +518,8 @@ public class VmStateCallback extends StateUpdateMessageCallback<Cluster, VmDescr
   }
 
   @TypeMapper
-  public enum VmDescribeResponseTypeToInstanceResourceReport implements Function<VmDescribeResponseType,InstanceResourceReportType> {
+  public enum VmDescribeResponseTypeToInstanceResourceReport implements Function<VmDescribeResponseType,
+      InstanceResourceReportType> {
     INSTANCE;
 
     @Nullable
