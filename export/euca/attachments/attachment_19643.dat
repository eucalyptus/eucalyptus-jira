diff --git a/clc/modules/object-storage/src/main/java/com/eucalyptus/objectstorage/ObjectStorageGateway.java b/clc/modules/object-storage/src/main/java/com/eucalyptus/objectstorage/ObjectStorageGateway.java
index 8753904..ff32264 100644
--- a/clc/modules/object-storage/src/main/java/com/eucalyptus/objectstorage/ObjectStorageGateway.java
+++ b/clc/modules/object-storage/src/main/java/com/eucalyptus/objectstorage/ObjectStorageGateway.java
@@ -1014,38 +1014,6 @@ public class ObjectStorageGateway implements ObjectStorageService {
         }
     }
 
-	/**
-	 * Common lookupBucket routine used by simple and extended GETs.
-	 */
-	protected DefaultHttpResponse createHttpResponse(ObjectStorageDataGetResponseType reply) {
-		DefaultHttpResponse httpResponse = new DefaultHttpResponse(
-				HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
-		long contentLength = reply.getSize();
-		String contentType = reply.getContentType();
-		String etag = reply.getEtag();
-		Date lastModified = reply.getLastModified();
-		String contentDisposition = reply.getContentDisposition();
-		httpResponse.addHeader( HttpHeaders.Names.CONTENT_TYPE, contentType != null ? contentType : "binary/octet-stream" );
-		if(etag != null)
-			httpResponse.addHeader(HttpHeaders.Names.ETAG, "\"" + etag + "\""); //etag in quotes, per s3-spec.
-		httpResponse.addHeader(HttpHeaders.Names.LAST_MODIFIED, DateFormatter.dateToHeaderFormattedString(lastModified));
-		if(contentDisposition != null) {
-			httpResponse.addHeader("Content-Disposition", contentDisposition);
-		}
-		httpResponse.addHeader( HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(contentLength));
-		String versionId = reply.getVersionId();
-		if(versionId != null) {
-			httpResponse.addHeader(ObjectStorageProperties.X_AMZ_VERSION_ID, versionId);
-		}
-		httpResponse.setHeader(HttpHeaders.Names.DATE, DateFormatter.dateToHeaderFormattedString(new Date()));
-		
-		//write extra headers
-		if(reply.getByteRangeEnd() != null) {
-			httpResponse.addHeader("Content-Range", reply.getByteRangeStart() + "-" + reply.getByteRangeEnd() + "/" + reply.getSize());
-		}
-		return httpResponse;
-	}
-
 	/* (non-Javadoc)
 	 * @see com.eucalyptus.objectstorage.ObjectStorageService#GetObject(com.eucalyptus.objectstorage.msgs.GetObjectType)
 	 */
diff --git a/clc/modules/walrus-common/src/main/java/com/eucalyptus/walrus/msgs/Walrus.groovy b/clc/modules/walrus-common/src/main/java/com/eucalyptus/walrus/msgs/Walrus.groovy
index 6759825..7f6f8de 100644
--- a/clc/modules/walrus-common/src/main/java/com/eucalyptus/walrus/msgs/Walrus.groovy
+++ b/clc/modules/walrus-common/src/main/java/com/eucalyptus/walrus/msgs/Walrus.groovy
@@ -89,7 +89,8 @@ import com.eucalyptus.storage.msgs.s3.LoggingEnabled;
 import com.eucalyptus.storage.msgs.s3.KeyEntry;
 import com.eucalyptus.storage.msgs.s3.Part
 import com.eucalyptus.auth.principal.User;
-import com.eucalyptus.auth.principal.Principals;
+import com.eucalyptus.auth.principal.Principals
+import org.jboss.netty.handler.stream.ChunkedInput;
 
 @ComponentMessage(WalrusBackend.class)
 public class WalrusResponseType extends BaseMessage {
@@ -396,6 +397,9 @@ public class WalrusDataGetRequestType extends WalrusDataRequestType {
 }
 
 public class WalrusDataGetResponseType extends WalrusDataResponseType {
+    List<ChunkedInput> dataInputStream;
+    Long byteRangeStart;
+    Long byteRangeEnd;
 
 	def WalrusDataGetResponseType() {}
 }
@@ -610,7 +614,7 @@ public class GetObjectExtendedType extends WalrusDataGetRequestType {
 	Boolean returnCompleteObjectOnConditionFailure;
 }
 
-public class GetObjectExtendedResponseType extends WalrusDataResponseType {
+public class GetObjectExtendedResponseType extends WalrusDataGetResponseType {
 	Status status;
 }
 
diff --git a/clc/modules/walrus-common/src/main/java/com/eucalyptus/walrus/util/WalrusProperties.java b/clc/modules/walrus-common/src/main/java/com/eucalyptus/walrus/util/WalrusProperties.java
index 639bb04..21e1455 100644
--- a/clc/modules/walrus-common/src/main/java/com/eucalyptus/walrus/util/WalrusProperties.java
+++ b/clc/modules/walrus-common/src/main/java/com/eucalyptus/walrus/util/WalrusProperties.java
@@ -103,6 +103,7 @@ public class WalrusProperties {
 	public static final String USAGE_LIMITS_PROPERTY = "euca.walrus.usageLimits";
 	public static final String AMZ_META_HEADER_PREFIX = "x-amz-meta-";
 	public static final String AMZ_ACL = "x-amz-acl";
+    public static final String AMZ_REQUEST_ID = "x-amz-request-id";
 
 	public static final String ALL_USERS_GROUP = "http://acs.amazonaws.com/groups/global/AllUsers";
 	public static final String AUTHENTICATED_USERS_GROUP = "http://acs.amazonaws.com/groups/global/AuthenticatedUsers";
diff --git a/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/StorageManager.java b/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/StorageManager.java
index 9dd75c8..2160599 100644
--- a/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/StorageManager.java
+++ b/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/StorageManager.java
@@ -66,7 +66,9 @@ import java.io.IOException;
 import java.util.List;
 
 import com.eucalyptus.walrus.entities.PartInfo;
+import com.eucalyptus.walrus.exceptions.WalrusException;
 import com.eucalyptus.walrus.msgs.GetObjectType;
+import com.eucalyptus.walrus.msgs.WalrusDataGetResponseType;
 import org.jboss.netty.handler.codec.http.DefaultHttpResponse;
 
 import com.eucalyptus.storage.common.fs.FileIO;
@@ -111,18 +113,13 @@ public interface StorageManager {
 
     public String getObjectPath(String bucket, String object);
 
-    public long getObjectSize(String bucket, String object);
+    public void getObject(String bucketName, String objectName, WalrusDataGetResponseType reply, Long size, Boolean isCompressed) throws WalrusException;
 
-    public void sendObject(WalrusDataGetRequestType request, DefaultHttpResponse httpResponse, String bucketName, String objectName, 
-			long size, String etag, String lastModified, String contentType, String contentDisposition, Boolean isCompressed, String versionId, BucketLogData logData);
+    public void getObject(String bucketName, String objectName, WalrusDataGetResponseType reply, Long byteRangeStart, Long byteRangeEnd, Boolean isCompressed) throws WalrusException;
 
-    public void sendObject(WalrusDataGetRequestType request, DefaultHttpResponse httpResponse, String bucketName, String objectName, 
-			long start, long end, long size, String etag, String lastModified, String contentType, String contentDisposition, Boolean isCompressed, String versionId, BucketLogData logData);
+    public void getMultipartObject(WalrusDataGetResponseType reply, List<PartInfo> parts, Boolean isCompressed) throws WalrusException;
 
-    public void sendHeaders(WalrusDataGetRequestType request, DefaultHttpResponse httpResponse, Long size, String etag,
-			String lastModified, String contentType, String contentDisposition, String versionId, BucketLogData logData);
-	
-	public void disable() throws EucalyptusCloudException ;
+    public void disable() throws EucalyptusCloudException ;
 
 	public void enable() throws EucalyptusCloudException;
 
@@ -131,6 +128,4 @@ public interface StorageManager {
 	public void check() throws EucalyptusCloudException;
 
 	public void start() throws EucalyptusCloudException;
-
-    void sendObject(WalrusDataGetRequestType request, DefaultHttpResponse httpResponse, List<PartInfo> parts, Long size, String etag, String lastModified, String contentType, String contentDisposition, Boolean isCompressed, String versionId);
 }
diff --git a/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/WalrusFSManager.java b/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/WalrusFSManager.java
index f9ddda0..937a9b2 100644
--- a/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/WalrusFSManager.java
+++ b/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/WalrusFSManager.java
@@ -454,38 +454,38 @@ public class WalrusFSManager extends WalrusManager {
                 throw new BucketAlreadyExistsException(bucketName);
             }
         } else {
-                // create bucket and set its acl
-                BucketInfo bucket = new BucketInfo(account.getAccountNumber(), ctx.getUser().getUserId(), bucketName, new Date());
-                ArrayList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();
-                bucket.addGrants(account.getAccountNumber(), grantInfos, accessControlList);
-                bucket.setGrants(grantInfos);
-                bucket.setBucketSize(0L);
-                bucket.setLoggingEnabled(false);
-                bucket.setVersioning(WalrusProperties.VersioningStatus.Disabled.toString());
-                bucket.setHidden(false);
-                if (locationConstraint != null && locationConstraint.length() > 0) {
-                    bucket.setLocation(locationConstraint);
-                } else {
-                    bucket.setLocation(null);
-                }
+            // create bucket and set its acl
+            BucketInfo bucket = new BucketInfo(account.getAccountNumber(), ctx.getUser().getUserId(), bucketName, new Date());
+            ArrayList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();
+            bucket.addGrants(account.getAccountNumber(), grantInfos, accessControlList);
+            bucket.setGrants(grantInfos);
+            bucket.setBucketSize(0L);
+            bucket.setLoggingEnabled(false);
+            bucket.setVersioning(WalrusProperties.VersioningStatus.Disabled.toString());
+            bucket.setHidden(false);
+            if (locationConstraint != null && locationConstraint.length() > 0) {
+                bucket.setLocation(locationConstraint);
+            } else {
+                bucket.setLocation(null);
+            }
 
-                // call the storage manager to save the bucket to disk
-                try {
-                    db.add(bucket);
-                    db.commit();
-                    storageManager.createBucket(bucketName);
-                } catch (IOException ex) {
-                    LOG.error(ex, ex);
+            // call the storage manager to save the bucket to disk
+            try {
+                db.add(bucket);
+                db.commit();
+                storageManager.createBucket(bucketName);
+            } catch (IOException ex) {
+                LOG.error(ex, ex);
+                throw new BucketAlreadyExistsException(bucketName);
+            } catch (Exception ex) {
+                LOG.error(ex, ex);
+                db.rollback();
+                if (Exceptions.isCausedBy(ex, ConstraintViolationException.class)) {
                     throw new BucketAlreadyExistsException(bucketName);
-                } catch (Exception ex) {
-                    LOG.error(ex, ex);
-                    db.rollback();
-                    if (Exceptions.isCausedBy(ex, ConstraintViolationException.class)) {
-                        throw new BucketAlreadyExistsException(bucketName);
-                    } else {
-                        throw new InternalErrorException("Unable to create bucket: " + bucketName);
-                    }
+                } else {
+                    throw new InternalErrorException("Unable to create bucket: " + bucketName);
                 }
+            }
 
         }
         reply.setBucket(bucketName);
@@ -628,7 +628,7 @@ public class WalrusFSManager extends WalrusManager {
                 reply.setLogData(logData);
             }
             ownerId = bucket.getOwnerId();
-                ArrayList<Grant> grants = new ArrayList<Grant>();
+            ArrayList<Grant> grants = new ArrayList<Grant>();
             bucket.readPermissions(grants);
 
             // Construct the grant list from the returned infos
@@ -1017,16 +1017,54 @@ public class WalrusFSManager extends WalrusManager {
                 // TODO(wenye): should handle this properly.
                 objSize = 1L;
             }
-                if (logData != null) {
-                    reply.setLogData(logData);
-                }
-                String objectName = null;
-                String versionId = null;
-                Long oldObjectSize = 0L;
-                ObjectInfo objectInfo = null;
-                if (bucket.isVersioningEnabled()) {
-                    // If versioning, add new object with new version id and
-                    // make it the 'latest' version.
+            if (logData != null) {
+                reply.setLogData(logData);
+            }
+            String objectName = null;
+            String versionId = null;
+            Long oldObjectSize = 0L;
+            ObjectInfo objectInfo = null;
+            if (bucket.isVersioningEnabled()) {
+                // If versioning, add new object with new version id and
+                // make it the 'latest' version.
+                objectInfo = new ObjectInfo(bucketName, objectKey);
+                objectInfo.setOwnerId(account.getAccountNumber());
+                List<GrantInfo> grantInfos = new ArrayList<GrantInfo>();
+                objectInfo.addGrants(account.getAccountNumber(), bucket.getOwnerId(), grantInfos, accessControlList);
+                objectInfo.setGrants(grantInfos);
+                objectName = UUID.randomUUID().toString();
+                objectInfo.setObjectName(objectName);
+                objectInfo.setSize(0L);
+                versionId = UUID.randomUUID().toString().replaceAll("-", "");
+                reply.setVersionId(versionId);
+            } else {
+                // If no versioning enabled, put using a null version id,
+                // this will replace any previous 'null' versioned object
+                // but not one with a version id.
+                versionId = WalrusProperties.NULL_VERSION_ID;
+                ObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);
+                searchObject.setVersionId(versionId);
+                EntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);
+                try {
+                    ObjectInfo foundObject = dbObject.getUniqueEscape(searchObject);
+                    if (!foundObject.canWrite(account.getAccountNumber())) {
+                        // Found existing object, but don't have write
+                        // access
+                        db.rollback();
+                        messenger.removeQueue(key, randomKey);
+                        throw new AccessDeniedException("Key", objectKey, logData);
+                    }
+                    objectName = foundObject.getObjectName();
+                    oldObjectSize = foundObject.getSize() == null ? 0L : foundObject.getSize();
+                    // Fix for EUCA-2275:
+                    // If an existing object is overwritten, the size
+                    // difference must be taken into account. Size of the
+                    // already existing object was ignored before
+                    oldBucketSize = -oldObjectSize;
+                } catch (AccessDeniedException ex) {
+                    throw ex;
+                } catch (EucalyptusCloudException ex) {
+                    // No existing object found
                     objectInfo = new ObjectInfo(bucketName, objectKey);
                     objectInfo.setOwnerId(account.getAccountNumber());
                     List<GrantInfo> grantInfos = new ArrayList<GrantInfo>();
@@ -1035,285 +1073,232 @@ public class WalrusFSManager extends WalrusManager {
                     objectName = UUID.randomUUID().toString();
                     objectInfo.setObjectName(objectName);
                     objectInfo.setSize(0L);
-                    versionId = UUID.randomUUID().toString().replaceAll("-", "");
-                    reply.setVersionId(versionId);
-                } else {
-                    // If no versioning enabled, put using a null version id,
-                    // this will replace any previous 'null' versioned object
-                    // but not one with a version id.
-                    versionId = WalrusProperties.NULL_VERSION_ID;
-                    ObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);
-                    searchObject.setVersionId(versionId);
-                    EntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);
-                    try {
-                        ObjectInfo foundObject = dbObject.getUniqueEscape(searchObject);
-                        if (!foundObject.canWrite(account.getAccountNumber())) {
-                            // Found existing object, but don't have write
-                            // access
-                            db.rollback();
-                            messenger.removeQueue(key, randomKey);
-                            throw new AccessDeniedException("Key", objectKey, logData);
-                        }
-                        objectName = foundObject.getObjectName();
-                        oldObjectSize = foundObject.getSize() == null ? 0L : foundObject.getSize();
-                        // Fix for EUCA-2275:
-                        // If an existing object is overwritten, the size
-                        // difference must be taken into account. Size of the
-                        // already existing object was ignored before
-                        oldBucketSize = -oldObjectSize;
-                    } catch (AccessDeniedException ex) {
-                        throw ex;
-                    } catch (EucalyptusCloudException ex) {
-                        // No existing object found
-                        objectInfo = new ObjectInfo(bucketName, objectKey);
-                        objectInfo.setOwnerId(account.getAccountNumber());
-                        List<GrantInfo> grantInfos = new ArrayList<GrantInfo>();
-                        objectInfo.addGrants(account.getAccountNumber(), bucket.getOwnerId(), grantInfos, accessControlList);
-                        objectInfo.setGrants(grantInfos);
-                        objectName = UUID.randomUUID().toString();
-                        objectInfo.setObjectName(objectName);
-                        objectInfo.setSize(0L);
-                    }
                 }
+            }
 
-                String bucketOwnerId = bucket.getOwnerId();
-                db.commit();
-                // writes are unconditional
-                WalrusDataQueue<WalrusDataMessage> putQueue = messenger.getQueue(key, randomKey);
+            String bucketOwnerId = bucket.getOwnerId();
+            db.commit();
+            // writes are unconditional
+            WalrusDataQueue<WalrusDataMessage> putQueue = messenger.getQueue(key, randomKey);
 
-                try {
-                    WalrusDataMessage dataMessage;
-                    String tempObjectName = objectName;
-                    MessageDigest digest = null;
-                    long size = 0;
-                    FileIO fileIO = null;
-                    while ((dataMessage = putQueue.poll(60L, TimeUnit.SECONDS)) != null) {
-                        if (putQueue.getInterrupted()) {
-                            if (WalrusDataMessage.isEOF(dataMessage)) {
-                                WalrusMonitor monitor = messenger.getMonitor(key);
-                                if (monitor.getLastModified() == null) {
-                                    LOG.trace("Monitor wait: " + key + " random: " + randomKey);
-                                    synchronized (monitor) {
-                                        monitor.wait();
-                                    }
-                                }
-                                LOG.trace("Monitor resume: " + key + " random: " + randomKey);
-                                lastModified = monitor.getLastModified();
-                                md5 = monitor.getMd5();
-                                // ok we are done here
-                                if (fileIO != null) {
-                                    fileIO.finish();
-                                }
-                                ObjectDeleter objectDeleter = new ObjectDeleter(bucketName,
-                                        tempObjectName,
-                                        null,
-                                        null,
-                                        null,
-                                        -1L,
-                                        ctx.getUser().getName(),
-                                        ctx.getUser().getUserId(),
-                                        ctx.getAccount().getName(),
-                                        ctx.getAccount().getAccountNumber());
-                                Threads.lookup(WalrusBackend.class, WalrusFSManager.ObjectDeleter.class).limitTo(10).submit(objectDeleter);
-                                LOG.info("Transfer interrupted: "+ key);
-                                messenger.removeQueue(key, randomKey);
-                                break;
-                            }
-                            continue;
-                        }
-                        if (WalrusDataMessage.isStart(dataMessage)) {
-                            tempObjectName = UUID.randomUUID().toString();
-                            digest = Digest.MD5.get();
-                            try {
-                                fileIO = storageManager.prepareForWrite(bucketName, tempObjectName);
-                            } catch (Exception ex) {
-                                messenger.removeQueue(key, randomKey);
-                                throw new AccessDeniedException(ex);
-                            }
-                        } else if (WalrusDataMessage.isEOF(dataMessage)) {
-                            if (digest != null) {
-                                md5 = Hashes.bytesToHex(digest.digest());
-                            } else {
-                                WalrusMonitor monitor = messenger.getMonitor(key);
-                                md5 = monitor.getMd5();
-                                lastModified = monitor.getLastModified();
-                                if (md5 == null) {
-                                    LOG.error("ETag did not match for: " + randomKey + " Computed MD5 is null");
-                                    throw new ContentMismatchException(bucketName + "/" + objectKey);
+            try {
+                WalrusDataMessage dataMessage;
+                String tempObjectName = objectName;
+                MessageDigest digest = null;
+                long size = 0;
+                FileIO fileIO = null;
+                while ((dataMessage = putQueue.poll(60L, TimeUnit.SECONDS)) != null) {
+                    if (putQueue.getInterrupted()) {
+                        if (WalrusDataMessage.isEOF(dataMessage)) {
+                            WalrusMonitor monitor = messenger.getMonitor(key);
+                            if (monitor.getLastModified() == null) {
+                                LOG.trace("Monitor wait: " + key + " random: " + randomKey);
+                                synchronized (monitor) {
+                                    monitor.wait();
                                 }
-                                break;
                             }
-                            String contentMD5 = request.getContentMD5();
-                            if (contentMD5 != null) {
-                                String contentMD5AsHex = Hashes.bytesToHex(Base64.decode(contentMD5));
-                                if (!contentMD5AsHex.equals(md5)) {
-                                    if (fileIO != null) {
-                                        fileIO.finish();
-                                    }
-                                    cleanupTempObject(ctx, bucketName, tempObjectName);
-                                    messenger.removeQueue(key, randomKey);
-                                    LOG.error("ETag did not match for: " + randomKey + " Expected: " + contentMD5AsHex + " Computed: " + md5);
-                                    throw new ContentMismatchException(bucketName + "/" + objectKey);
-                                }
+                            LOG.trace("Monitor resume: " + key + " random: " + randomKey);
+                            lastModified = monitor.getLastModified();
+                            md5 = monitor.getMd5();
+                            // ok we are done here
+                            if (fileIO != null) {
+                                fileIO.finish();
                             }
-
-                            // Fix for EUCA-2275:
-                            // Moved up policy and bucket size checks on the
-                            // temporary object. The temp object is committed
-                            // (renamed) only after it clears the checks.
-                            // If any of the checks fail, temp object is cleaned
-                            // up and the process errors out. If the PUT request
-                            // is overwriting an existing object, the object is
-                            // left untouched.
-                            // So the fix ensures proper clean up of temp files
-                            // (no orphaned files) and does not overwrite
-                            // existing data when policy or bucket size checks
-                            // fail
-
-                            if (!ctx.hasAdministrativePrivileges()
-                                    && !Permissions.canAllocate(PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, bucketName, PolicySpec.S3_PUTOBJECT,
-                                    ctx.getUser(), oldBucketSize + size)) {
-                                // dbObject.rollback();
-                                cleanupTempObject(ctx, bucketName, tempObjectName);
-                                messenger.removeQueue(key, randomKey);
-                                LOG.error("Quota exceeded for WalrusBackend putObject");
-                                throw new EntityTooLargeException("Key", objectKey);
+                            ObjectDeleter objectDeleter = new ObjectDeleter(bucketName,
+                                    tempObjectName,
+                                    null,
+                                    null,
+                                    null,
+                                    -1L,
+                                    ctx.getUser().getName(),
+                                    ctx.getUser().getUserId(),
+                                    ctx.getAccount().getName(),
+                                    ctx.getAccount().getAccountNumber());
+                            Threads.lookup(WalrusBackend.class, WalrusFSManager.ObjectDeleter.class).limitTo(10).submit(objectDeleter);
+                            LOG.info("Transfer interrupted: "+ key);
+                            messenger.removeQueue(key, randomKey);
+                            break;
+                        }
+                        continue;
+                    }
+                    if (WalrusDataMessage.isStart(dataMessage)) {
+                        tempObjectName = UUID.randomUUID().toString();
+                        digest = Digest.MD5.get();
+                        try {
+                            fileIO = storageManager.prepareForWrite(bucketName, tempObjectName);
+                        } catch (Exception ex) {
+                            messenger.removeQueue(key, randomKey);
+                            throw new AccessDeniedException(ex);
+                        }
+                    } else if (WalrusDataMessage.isEOF(dataMessage)) {
+                        if (digest != null) {
+                            md5 = Hashes.bytesToHex(digest.digest());
+                        } else {
+                            WalrusMonitor monitor = messenger.getMonitor(key);
+                            md5 = monitor.getMd5();
+                            lastModified = monitor.getLastModified();
+                            if (md5 == null) {
+                                LOG.error("ETag did not match for: " + randomKey + " Computed MD5 is null");
+                                throw new ContentMismatchException(bucketName + "/" + objectKey);
                             }
-                            boolean success = true;
-
-                            // commit object
-                            try {
+                            break;
+                        }
+                        String contentMD5 = request.getContentMD5();
+                        if (contentMD5 != null) {
+                            String contentMD5AsHex = Hashes.bytesToHex(Base64.decode(contentMD5));
+                            if (!contentMD5AsHex.equals(md5)) {
                                 if (fileIO != null) {
                                     fileIO.finish();
                                 }
-                                storageManager.renameObject(bucketName, tempObjectName, objectName);
-                            } catch (IOException ex) {
-                                LOG.error(ex);
+                                cleanupTempObject(ctx, bucketName, tempObjectName);
                                 messenger.removeQueue(key, randomKey);
-                                throw new AccessDeniedException(objectKey);
+                                LOG.error("ETag did not match for: " + randomKey + " Expected: " + contentMD5AsHex + " Computed: " + md5);
+                                throw new ContentMismatchException(bucketName + "/" + objectKey);
                             }
-                            lastModified = new Date();
-                            ObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);
-                            searchObject.setVersionId(versionId);
-                            EntityWrapper<ObjectInfo> dbObject = EntityWrapper.get(ObjectInfo.class);
-                            ObjectInfo foundObject;
-                            try {
-                                foundObject = dbObject.getUniqueEscape(searchObject);
-                                // If its a delete marker, fall through the administrative privileges and ACP check
-                                if (foundObject.getDeleted() || ctx.hasAdministrativePrivileges() || foundObject.canWriteACP(account.getAccountNumber())) {
-                                    List<GrantInfo> grantInfos = new ArrayList<GrantInfo>();
-                                    foundObject.addGrants(account.getAccountNumber(), bucketOwnerId, grantInfos, accessControlList);
-                                    foundObject.setGrants(grantInfos);
-                                }
-                                /*if (WalrusProperties.enableTorrents) {
-                                    EntityWrapper<TorrentInfo> dbTorrent = dbObject.recast(TorrentInfo.class);
-                                    TorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);
-                                    List<TorrentInfo> torrentInfos = dbTorrent.queryEscape(torrentInfo);
-                                    if (torrentInfos.size() > 0) {
-                                        TorrentInfo foundTorrentInfo = torrentInfos.get(0);
-                                        TorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);
-                                        if (torrentClient != null) {
-                                            torrentClient.bye();
-                                        }
-                                        dbTorrent.delete(foundTorrentInfo);
-                                    }
-                                } else {
-                                    LOG.warn("Bittorrent support has been disabled. Please check pre-requisites");
-                                }*/
-                            } catch (EucalyptusCloudException ex) {
-                                if (objectInfo != null) {
-                                    foundObject = objectInfo;
-                                } else {
-                                    dbObject.rollback();
-                                    throw new InternalErrorException("Unable to update object: " + bucketName + "/" + objectKey);
-                                }
+                        }
+
+                        // Fix for EUCA-2275:
+                        // Moved up policy and bucket size checks on the
+                        // temporary object. The temp object is committed
+                        // (renamed) only after it clears the checks.
+                        // If any of the checks fail, temp object is cleaned
+                        // up and the process errors out. If the PUT request
+                        // is overwriting an existing object, the object is
+                        // left untouched.
+                        // So the fix ensures proper clean up of temp files
+                        // (no orphaned files) and does not overwrite
+                        // existing data when policy or bucket size checks
+                        // fail
+
+                        if (!ctx.hasAdministrativePrivileges()
+                                && !Permissions.canAllocate(PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, bucketName, PolicySpec.S3_PUTOBJECT,
+                                ctx.getUser(), oldBucketSize + size)) {
+                            // dbObject.rollback();
+                            cleanupTempObject(ctx, bucketName, tempObjectName);
+                            messenger.removeQueue(key, randomKey);
+                            LOG.error("Quota exceeded for WalrusBackend putObject");
+                            throw new EntityTooLargeException("Key", objectKey);
+                        }
+                        boolean success = true;
+
+                        // commit object
+                        try {
+                            if (fileIO != null) {
+                                fileIO.finish();
                             }
-                            foundObject.setVersionId(versionId);
-                            foundObject.replaceMetaData(request.getMetaData());
-                            foundObject.setEtag(md5);
-                            foundObject.setSize(size);
-                            foundObject.setLastModified(lastModified);
-                            foundObject.setStorageClass("STANDARD");
-                            foundObject.setContentType(request.getContentType());
-                            foundObject.setContentDisposition(request.getContentDisposition());
-                            foundObject.setLast(true);
-                            foundObject.setDeleted(false);
-                            reply.setSize(size);
-                            if (logData != null) {
-                                logData.setObjectSize(size);
-                                updateLogData(bucket, logData);
+                            storageManager.renameObject(bucketName, tempObjectName, objectName);
+                        } catch (IOException ex) {
+                            LOG.error(ex);
+                            messenger.removeQueue(key, randomKey);
+                            throw new AccessDeniedException(objectKey);
+                        }
+                        lastModified = new Date();
+                        ObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);
+                        searchObject.setVersionId(versionId);
+                        EntityWrapper<ObjectInfo> dbObject = EntityWrapper.get(ObjectInfo.class);
+                        ObjectInfo foundObject;
+                        try {
+                            foundObject = dbObject.getUniqueEscape(searchObject);
+                            // If its a delete marker, fall through the administrative privileges and ACP check
+                            if (foundObject.getDeleted() || ctx.hasAdministrativePrivileges() || foundObject.canWriteACP(account.getAccountNumber())) {
+                                List<GrantInfo> grantInfos = new ArrayList<GrantInfo>();
+                                foundObject.addGrants(account.getAccountNumber(), bucketOwnerId, grantInfos, accessControlList);
+                                foundObject.setGrants(grantInfos);
                             }
+                        } catch (EucalyptusCloudException ex) {
                             if (objectInfo != null) {
-                                dbObject.add(foundObject);
-                            }
-                            success = false;
-                            try {
-                                dbObject.commit();
-                                success = true;
-                            } catch (RollbackException ex) {
+                                foundObject = objectInfo;
+                            } else {
                                 dbObject.rollback();
-                                LOG.error(ex, ex);
-                            }
-
-                            dbObject = EntityWrapper.get(ObjectInfo.class);
-                            List<ObjectInfo> objectInfos = dbObject.queryEscape(new ObjectInfo(bucketName, objectKey));
-                            for (ObjectInfo objInfo : objectInfos) {
-                                if (!success) {
-                                    if (objInfo.getLast()) {
-                                        lastModified = objInfo.getLastModified();
-                                        md5 = objInfo.getEtag();
-                                    }
-                                    success = true;
-                                }
-                                if (!versionId.equals(objInfo.getVersionId())) {
-                                    objInfo.setLast(false);
-                                }
+                                throw new InternalErrorException("Unable to update object: " + bucketName + "/" + objectKey);
                             }
+                        }
+                        foundObject.setVersionId(versionId);
+                        foundObject.replaceMetaData(request.getMetaData());
+                        foundObject.setEtag(md5);
+                        foundObject.setSize(size);
+                        foundObject.setLastModified(lastModified);
+                        foundObject.setStorageClass("STANDARD");
+                        foundObject.setContentType(request.getContentType());
+                        foundObject.setContentDisposition(request.getContentDisposition());
+                        foundObject.setLast(true);
+                        foundObject.setDeleted(false);
+                        reply.setSize(size);
+                        if (logData != null) {
+                            logData.setObjectSize(size);
+                            updateLogData(bucket, logData);
+                        }
+                        if (objectInfo != null) {
+                            dbObject.add(foundObject);
+                        }
+                        success = false;
+                        try {
                             dbObject.commit();
+                            success = true;
+                        } catch (RollbackException ex) {
+                            dbObject.rollback();
+                            LOG.error(ex, ex);
+                        }
 
-                            if (logData != null) {
-                                logData.setTurnAroundTime(Long.parseLong(new String(dataMessage.getPayload())));
+                        dbObject = EntityWrapper.get(ObjectInfo.class);
+                        List<ObjectInfo> objectInfos = dbObject.queryEscape(new ObjectInfo(bucketName, objectKey));
+                        for (ObjectInfo objInfo : objectInfos) {
+                            if (!success) {
+                                if (objInfo.getLast()) {
+                                    lastModified = objInfo.getLastModified();
+                                    md5 = objInfo.getEtag();
+                                }
+                                success = true;
                             }
-                            // restart all interrupted puts
-                            WalrusMonitor monitor = messenger.getMonitor(key);
-                            synchronized (monitor) {
-                                monitor.setLastModified(lastModified);
-                                monitor.setMd5(md5);
-                                monitor.notifyAll();
+                            if (!versionId.equals(objInfo.getVersionId())) {
+                                objInfo.setLast(false);
                             }
-                            // messenger.removeMonitor(key);
-                            messenger.clearQueues(key);
-                            messenger.removeQueue(key, randomKey);
-                            LOG.info("Transfer complete: " + key);
+                        }
+                        dbObject.commit();
 
-                            break;
-                        } else {
-                            assert (WalrusDataMessage.isData(dataMessage));
-                            byte[] data = dataMessage.getPayload();
-                            // start writing object (but do not commit yet)
-                            try {
-                                if (fileIO != null)
-                                    fileIO.write(data);
-                            } catch (IOException ex) {
-                                LOG.error(ex);
-                            }
-                            // calculate md5 on the fly
-                            size += data.length;
-                            if (digest != null) {
-                                digest.update(data);
-                            }
+                        if (logData != null) {
+                            logData.setTurnAroundTime(Long.parseLong(new String(dataMessage.getPayload())));
                         }
-                    }
-                    if (dataMessage == null) {
-                        db.rollback();
+                        // restart all interrupted puts
+                        WalrusMonitor monitor = messenger.getMonitor(key);
+                        synchronized (monitor) {
+                            monitor.setLastModified(lastModified);
+                            monitor.setMd5(md5);
+                            monitor.notifyAll();
+                        }
+                        // messenger.removeMonitor(key);
+                        messenger.clearQueues(key);
                         messenger.removeQueue(key, randomKey);
-                        throw new InternalErrorException("Put timed out: " + key + "." + randomKey);
+                        LOG.info("Transfer complete: " + key);
+
+                        break;
+                    } else {
+                        assert (WalrusDataMessage.isData(dataMessage));
+                        byte[] data = dataMessage.getPayload();
+                        // start writing object (but do not commit yet)
+                        try {
+                            if (fileIO != null)
+                                fileIO.write(data);
+                        } catch (IOException ex) {
+                            LOG.error(ex);
+                        }
+                        // calculate md5 on the fly
+                        size += data.length;
+                        if (digest != null) {
+                            digest.update(data);
+                        }
                     }
-                } catch (InterruptedException ex) {
-                    LOG.error(ex, ex);
+                }
+                if (dataMessage == null) {
+                    db.rollback();
                     messenger.removeQueue(key, randomKey);
-                    throw new InternalErrorException("Transfer interrupted: " + key + "." + randomKey);
+                    throw new InternalErrorException("Put timed out: " + key + "." + randomKey);
                 }
+            } catch (InterruptedException ex) {
+                LOG.error(ex, ex);
+                messenger.removeQueue(key, randomKey);
+                throw new InternalErrorException("Transfer interrupted: " + key + "." + randomKey);
+            }
         } else {
             db.rollback();
             messenger.removeQueue(key, randomKey);
@@ -1441,106 +1426,106 @@ public class WalrusFSManager extends WalrusManager {
                 // TODO(wenye): should handle this properly.
                 objSize = 1L;
             }
-                EntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);
-                ObjectInfo searchObjectInfo = new ObjectInfo();
-                searchObjectInfo.setBucketName(bucketName);
-
-                ObjectInfo foundObject = null;
-                List<ObjectInfo> objectInfos = dbObject.queryEscape(searchObjectInfo);
-                for (ObjectInfo objectInfo : objectInfos) {
-                    if (objectInfo.getObjectKey().equals(objectKey)) {
-                        // key (object) exists. check perms
-                        if (!objectInfo.canWrite(account.getAccountNumber())) {
-                            db.rollback();
-                            throw new AccessDeniedException("Key", objectKey, logData);
-                        }
-                        foundObject = objectInfo;
-                        oldBucketSize = -foundObject.getSize();
-                        break;
+            EntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);
+            ObjectInfo searchObjectInfo = new ObjectInfo();
+            searchObjectInfo.setBucketName(bucketName);
+
+            ObjectInfo foundObject = null;
+            List<ObjectInfo> objectInfos = dbObject.queryEscape(searchObjectInfo);
+            for (ObjectInfo objectInfo : objectInfos) {
+                if (objectInfo.getObjectKey().equals(objectKey)) {
+                    // key (object) exists. check perms
+                    if (!objectInfo.canWrite(account.getAccountNumber())) {
+                        db.rollback();
+                        throw new AccessDeniedException("Key", objectKey, logData);
                     }
+                    foundObject = objectInfo;
+                    oldBucketSize = -foundObject.getSize();
+                    break;
                 }
-                // write object to bucket
-                String objectName;
-                Long oldObjectSize = 0L;
-                if (foundObject == null) {
-                    // not found. create an object info
-                    foundObject = new ObjectInfo(bucketName, objectKey);
-                    foundObject.setOwnerId(account.getAccountNumber());
-                    List<GrantInfo> grantInfos = new ArrayList<GrantInfo>();
+            }
+            // write object to bucket
+            String objectName;
+            Long oldObjectSize = 0L;
+            if (foundObject == null) {
+                // not found. create an object info
+                foundObject = new ObjectInfo(bucketName, objectKey);
+                foundObject.setOwnerId(account.getAccountNumber());
+                List<GrantInfo> grantInfos = new ArrayList<GrantInfo>();
+                foundObject.addGrants(account.getAccountNumber(), bucket.getOwnerId(), grantInfos, accessControlList);
+                foundObject.setGrants(grantInfos);
+                objectName = UUID.randomUUID().toString();
+                foundObject.setObjectName(objectName);
+                dbObject.add(foundObject);
+            } else {
+                // object already exists. see if we can modify acl
+                if (ctx.hasAdministrativePrivileges() || foundObject.canWriteACP(account.getAccountNumber())) {
+                    List<GrantInfo> grantInfos = foundObject.getGrants();
                     foundObject.addGrants(account.getAccountNumber(), bucket.getOwnerId(), grantInfos, accessControlList);
-                    foundObject.setGrants(grantInfos);
-                    objectName = UUID.randomUUID().toString();
-                    foundObject.setObjectName(objectName);
-                    dbObject.add(foundObject);
-                } else {
-                    // object already exists. see if we can modify acl
-                    if (ctx.hasAdministrativePrivileges() || foundObject.canWriteACP(account.getAccountNumber())) {
-                        List<GrantInfo> grantInfos = foundObject.getGrants();
-                        foundObject.addGrants(account.getAccountNumber(), bucket.getOwnerId(), grantInfos, accessControlList);
-                    }
-                    objectName = foundObject.getObjectName();
-                    oldObjectSize = foundObject.getSize();
                 }
-                foundObject.setObjectKey(objectKey);
+                objectName = foundObject.getObjectName();
+                oldObjectSize = foundObject.getSize();
+            }
+            foundObject.setObjectKey(objectKey);
+            try {
+                // writes are unconditional
+                if (request.getBase64Data().getBytes().length > WalrusProperties.MAX_INLINE_DATA_SIZE) {
+                    db.rollback();
+                    throw new InlineDataTooLargeException(bucketName + "/" + objectKey);
+                }
+                byte[] base64Data = Hashes.base64decode(request.getBase64Data()).getBytes();
+                foundObject.setObjectName(objectName);
+                Long size = (long) base64Data.length;
+
+                // Fix for EUCA-2275:
+                // Moved up policy and bucket size checks on the temporary
+                // object. The object is committed (written) only after it
+                // clears the checks.
+                // So the fix ensures that no files are orphaned and does
+                // not overwrite existing data when policy or bucket size
+                // checks fail
+
+                if (!ctx.hasAdministrativePrivileges()
+                        && !Permissions.canAllocate(PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, bucketName, PolicySpec.S3_PUTOBJECT,
+                        ctx.getUser(), oldBucketSize + size)) {
+                    db.rollback();
+                    LOG.error("Quota exceeded in WalrusBackend putObject");
+                    throw new EntityTooLargeException("Key", objectKey, logData);
+                }
+                boolean success = true;
                 try {
-                    // writes are unconditional
-                    if (request.getBase64Data().getBytes().length > WalrusProperties.MAX_INLINE_DATA_SIZE) {
-                        db.rollback();
-                        throw new InlineDataTooLargeException(bucketName + "/" + objectKey);
-                    }
-                    byte[] base64Data = Hashes.base64decode(request.getBase64Data()).getBytes();
-                    foundObject.setObjectName(objectName);
-                    Long size = (long) base64Data.length;
-
-                    // Fix for EUCA-2275:
-                    // Moved up policy and bucket size checks on the temporary
-                    // object. The object is committed (written) only after it
-                    // clears the checks.
-                    // So the fix ensures that no files are orphaned and does
-                    // not overwrite existing data when policy or bucket size
-                    // checks fail
-
-                    if (!ctx.hasAdministrativePrivileges()
-                            && !Permissions.canAllocate(PolicySpec.VENDOR_S3, PolicySpec.S3_RESOURCE_OBJECT, bucketName, PolicySpec.S3_PUTOBJECT,
-                            ctx.getUser(), oldBucketSize + size)) {
-                        db.rollback();
-                        LOG.error("Quota exceeded in WalrusBackend putObject");
-                        throw new EntityTooLargeException("Key", objectKey, logData);
+                    FileIO fileIO = storageManager.prepareForWrite(bucketName, objectName);
+                    if (fileIO != null) {
+                        fileIO.write(base64Data);
+                        fileIO.finish();
                     }
-                    boolean success = true;
-                    try {
-                        FileIO fileIO = storageManager.prepareForWrite(bucketName, objectName);
-                        if (fileIO != null) {
-                            fileIO.write(base64Data);
-                            fileIO.finish();
-                        }
-                    } catch (Exception ex) {
-                        db.rollback();
-                        throw new AccessDeniedException(ex);
-                    }
-                    md5 = Hashes.getHexString(Digest.MD5.get().digest(base64Data));
-                    foundObject.setEtag(md5);
-                    foundObject.setSize(size);
-                    // Add meta data if specified
-                    if (request.getMetaData() != null)
-                        foundObject.replaceMetaData(request.getMetaData());
-
-                    // TODO: add support for other storage classes
-                    foundObject.setStorageClass("STANDARD");
-                    lastModified = new Date();
-                    foundObject.setLastModified(lastModified);
-                    if (logData != null) {
-                        updateLogData(bucket, logData);
-                        logData.setObjectSize(size);
-                        reply.setLogData(logData);
-                    }
-
-					/* SOAP */
                 } catch (Exception ex) {
-                    LOG.error(ex);
                     db.rollback();
-                    throw new InternalErrorException(bucketName);
+                    throw new AccessDeniedException(ex);
                 }
+                md5 = Hashes.getHexString(Digest.MD5.get().digest(base64Data));
+                foundObject.setEtag(md5);
+                foundObject.setSize(size);
+                // Add meta data if specified
+                if (request.getMetaData() != null)
+                    foundObject.replaceMetaData(request.getMetaData());
+
+                // TODO: add support for other storage classes
+                foundObject.setStorageClass("STANDARD");
+                lastModified = new Date();
+                foundObject.setLastModified(lastModified);
+                if (logData != null) {
+                    updateLogData(bucket, logData);
+                    logData.setObjectSize(size);
+                    reply.setLogData(logData);
+                }
+
+					/* SOAP */
+            } catch (Exception ex) {
+                LOG.error(ex);
+                db.rollback();
+                throw new InternalErrorException(bucketName);
+            }
         } else {
             db.rollback();
             throw new NoSuchBucketException(bucketName);
@@ -2287,7 +2272,7 @@ public class WalrusFSManager extends WalrusManager {
                 db.rollback();
                 throw new WalrusException("InvalidArgument", "Invalid canned-acl or grant list permission: " + invalidValue, "Bucket",
                         bucket.getBucketName(), HttpResponseStatus.BAD_REQUEST);
-                }
+            }
             List<GrantInfo> grantInfos = new ArrayList<GrantInfo>();
             bucket.resetGlobalGrants();
             bucket.addGrants(bucket.getOwnerId(), grantInfos, accessControlList);
@@ -2351,24 +2336,6 @@ public class WalrusFSManager extends WalrusManager {
                 objectInfo.resetGlobalGrants();
                 objectInfo.addGrants(objectInfo.getOwnerId(), bucket.getOwnerId(), grantInfos, accessControlList);
                 objectInfo.setGrants(grantInfos);
-
-                if (WalrusProperties.enableTorrents) {
-                    if (!objectInfo.isGlobalRead()) {
-                        EntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);
-                        TorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);
-                        List<TorrentInfo> torrentInfos = dbTorrent.queryEscape(torrentInfo);
-                        if (torrentInfos.size() > 0) {
-                            TorrentInfo foundTorrentInfo = torrentInfos.get(0);
-                            TorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);
-                            if (torrentClient != null) {
-                                torrentClient.bye();
-                            }
-                            dbTorrent.delete(foundTorrentInfo);
-                        }
-                    }
-                } else {
-                    LOG.warn("Bittorrent support has been disabled. Please check pre-requisites");
-                }
                 reply.setCode("204");
                 reply.setDescription("OK");
                 if (logData != null) {
@@ -2437,24 +2404,6 @@ public class WalrusFSManager extends WalrusManager {
                 objectInfo.resetGlobalGrants();
                 objectInfo.addGrants(objectInfo.getOwnerId(), bucket.getOwnerId(), grantInfos, accessControlList);
                 objectInfo.setGrants(grantInfos);
-
-                if (WalrusProperties.enableTorrents) {
-                    if (!objectInfo.isGlobalRead()) {
-                        EntityWrapper<TorrentInfo> dbTorrent = db.recast(TorrentInfo.class);
-                        TorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);
-                        List<TorrentInfo> torrentInfos = dbTorrent.queryEscape(torrentInfo);
-                        if (torrentInfos.size() > 0) {
-                            TorrentInfo foundTorrentInfo = torrentInfos.get(0);
-                            TorrentClient torrentClient = Torrents.getClient(bucketName + objectKey);
-                            if (torrentClient != null) {
-                                torrentClient.bye();
-                            }
-                            dbTorrent.delete(foundTorrentInfo);
-                        }
-                    }
-                } else {
-                    LOG.warn("Bittorrent support has been disabled. Please check pre-requisites");
-                }
                 if (logData != null) {
                     updateLogData(bucket, logData);
                     logData.setObjectSize(objectInfo.getSize());
@@ -2488,11 +2437,6 @@ public class WalrusFSManager extends WalrusManager {
             deleteAfterGet = false;
         }
 
-        Boolean getTorrent = request.getGetTorrent();
-        if (getTorrent == null) {
-            getTorrent = false;
-        }
-
         Boolean getMetaData = request.getGetMetaData();
         if (getMetaData == null) {
             getMetaData = false;
@@ -2525,85 +2469,22 @@ public class WalrusFSManager extends WalrusManager {
             if (objectInfos.size() > 0) {
                 ObjectInfo objectInfo = objectInfos.get(0);
                 String objectName = objectInfo.getObjectName();
-                DefaultHttpResponse httpResponse = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
                 if (getMetaData) {
+                    ArrayList<MetaDataEntry> metaData = new ArrayList<MetaDataEntry>();
                     List<MetaDataInfo> metaDataInfos = objectInfo.getMetaData();
                     for (MetaDataInfo metaDataInfo : metaDataInfos) {
-                        httpResponse.addHeader(WalrusProperties.AMZ_META_HEADER_PREFIX + metaDataInfo.getName(), metaDataInfo.getValue());
+                        metaData.add(new MetaDataEntry(metaDataInfo.getName(), metaDataInfo.getValue()));
                     }
+                    reply.setMetaData(metaData);
                 }
 
-                /*if (getTorrent) {
-                    if (objectInfo.isGlobalRead()) {
-                        if (!WalrusProperties.enableTorrents) {
-                            LOG.warn("Bittorrent support has been disabled. Please check pre-requisites");
-                            throw new InternalErrorException("Torrents disabled");
-                        }
-                        EntityWrapper<TorrentInfo> dbTorrent = EntityWrapper.get(TorrentInfo.class);
-                        TorrentInfo torrentInfo = new TorrentInfo(bucketName, objectKey);
-                        TorrentInfo foundTorrentInfo;
-                        String absoluteObjectPath = storageManager.getObjectPath(bucketName, objectName);
-                        try {
-                            foundTorrentInfo = dbTorrent.getUniqueEscape(torrentInfo);
-                        } catch (EucalyptusCloudException ex) {
-                            String torrentFile = objectName + ".torrent";
-                            String torrentFilePath = storageManager.getObjectPath(bucketName, torrentFile);
-                            TorrentCreator torrentCreator = new TorrentCreator(absoluteObjectPath, objectKey, objectName, torrentFilePath,
-                                    WalrusProperties.getTrackerUrl());
-                            try {
-                                torrentCreator.create();
-                            } catch (Exception e) {
-                                LOG.error(e);
-                                throw new InternalErrorException("could not create torrent file " + torrentFile);
-                            }
-                            torrentInfo.setTorrentFile(torrentFile);
-                            dbTorrent.add(torrentInfo);
-                            foundTorrentInfo = torrentInfo;
-                        }
-                        dbTorrent.commit();
-                        String torrentFile = foundTorrentInfo.getTorrentFile();
-                        String torrentFilePath = storageManager.getObjectPath(bucketName, torrentFile);
-                        TorrentClient torrentClient = new TorrentClient(torrentFilePath, absoluteObjectPath);
-                        Torrents.addClient(bucketName + objectKey, torrentClient);
-                        torrentClient.start();
-                        // send torrent
-                        String key = bucketName + "." + objectKey;
-                        String randomKey = key + "." + Hashes.getRandom(10);
-                        request.setRandomKey(randomKey);
-
-                        File torrent = new File(torrentFilePath);
-                        if (torrent.exists()) {
-                            Date lastModified = objectInfo.getLastModified();
-                            db.commit();
-                            long torrentLength = torrent.length();
-                            if (logData != null) {
-                                updateLogData(bucket, logData);
-                                logData.setObjectSize(torrentLength);
-                            }
-                            storageManager.sendObject(request, httpResponse, bucketName, torrentFile, torrentLength, null,
-                                    DateUtils.format(lastModified.getTime(), DateUtils.RFC822_DATETIME_PATTERN), "application/x-bittorrent",
-                                    "attachment; filename=" + objectKey + ".torrent;", request.getIsCompressed(), null, logData);
-
-                            return null;
-                        } else {
-                            // No torrent exists
-                            db.rollback();
-                            String errorString = "Could not get torrent file " + torrentFilePath;
-                            LOG.error(errorString);
-                            throw new InternalErrorException(errorString);
-                        }
-                    } else {
-                        // No global object read permission
-                        db.rollback();
-                        throw new AccessDeniedException("Key", objectKey, logData);
-                    }
-                }*/
                 Date lastModified = objectInfo.getLastModified();
                 Long size = objectInfo.getSize();
                 String etag = objectInfo.getEtag();
                 String contentType = objectInfo.getContentType();
                 String contentDisposition = objectInfo.getContentDisposition();
                 db.commit();
+
                 if (logData != null) {
                     updateLogData(bucket, logData);
                     logData.setObjectSize(size);
@@ -2615,11 +2496,9 @@ public class WalrusFSManager extends WalrusManager {
                 if (request.getGetData()) {
                     //check if this is a multipart object
                     if (objectInfo.isMultipart()) {
-                        String inlineData = getMultipartData(httpResponse, objectInfo, request, reply);
+                        String inlineData = getMultipartData(objectInfo, request, reply);
                         if (inlineData != null) {
                             reply.setBase64Data(inlineData);
-                        } else {
-                            return null;
                         }
                     } else {
                         if (request.getInlineData()) {
@@ -2649,22 +2528,14 @@ public class WalrusFSManager extends WalrusManager {
                         } else {
                             reply.setHasStreamingData(true);
                             // support for large objects
-							storageManager.sendObject(request, httpResponse, bucketName, objectName, size, etag,
-									DateFormatter.dateToHeaderFormattedString(lastModified), contentType, contentDisposition, request.getIsCompressed(),
-									versionId, logData);
-
-                            return null;
+                            //fill in reply with useful things
+                            storageManager.getObject(bucketName, objectName, reply, size, request.getIsCompressed());
                         }
                     }
-                } else {
-                    // Request is for headers/metadata only
-					storageManager.sendHeaders(request, httpResponse, size, etag, DateFormatter.dateToHeaderFormattedString(lastModified), contentType,
-							contentDisposition, versionId, logData);
-                    return null;
-
                 }
                 reply.setEtag(etag);
                 reply.setLastModified(lastModified);
+                reply.setVersionId(versionId);
                 reply.setSize(size);
                 reply.setContentType(contentType);
                 reply.setContentDisposition(contentDisposition);
@@ -2709,9 +2580,6 @@ public class WalrusFSManager extends WalrusManager {
 
         String bucketName = request.getBucket();
         String objectKey = request.getKey();
-        Context ctx = Contexts.lookup();
-        Account account = ctx.getAccount();
-        Status status = new Status();
 
         Boolean getData = request.getGetData();
         if (getData == null) {
@@ -2787,10 +2655,12 @@ public class WalrusFSManager extends WalrusManager {
                     }
                 }
                 if (request.getGetMetaData()) {
+                    ArrayList<MetaDataEntry> metaData = new ArrayList<MetaDataEntry>();
                     List<MetaDataInfo> metaDataInfos = objectInfo.getMetaData();
                     for (MetaDataInfo metaDataInfo : metaDataInfos) {
-                        httpResponse.addHeader(WalrusProperties.AMZ_META_HEADER_PREFIX + metaDataInfo.getName(), metaDataInfo.getValue());
+                        metaData.add(new MetaDataEntry(metaDataInfo.getName(), metaDataInfo.getValue()));
                     }
+                    reply.setMetaData(metaData);
                 }
                 Long size = objectInfo.getSize();
                 String contentType = objectInfo.getContentType();
@@ -2805,15 +2675,21 @@ public class WalrusFSManager extends WalrusManager {
                     versionId = objectInfo.getVersionId() != null ? objectInfo.getVersionId() : WalrusProperties.NULL_VERSION_ID;
                 }
                 if (request.getGetData()) {
-					storageManager.sendObject(request, httpResponse, bucketName, objectName, byteRangeStart, byteRangeEnd + 1, size, etag,
-							DateFormatter.dateToHeaderFormattedString(lastModified), contentType, contentDisposition, request.getIsCompressed(), versionId,
-							logData);
-                    return null;
-                } else {
-					storageManager.sendHeaders(request, httpResponse, size, etag, DateFormatter.dateToHeaderFormattedString(lastModified), contentType,
-							contentDisposition, versionId, logData);
-                    return null;
+                    storageManager.getObject(bucketName, objectName, reply, byteRangeStart, byteRangeEnd + 1, request.getIsCompressed());
                 }
+                reply.setEtag(etag);
+                reply.setLastModified(lastModified);
+                reply.setSize(size);
+                reply.setContentType(contentType);
+                reply.setContentDisposition(contentDisposition);
+                reply.setByteRangeStart(byteRangeStart);
+                reply.setByteRangeEnd(byteRangeEnd);
+                reply.setVersionId(versionId);
+                Status status = new Status();
+                status.setCode(200);
+                status.setDescription("OK");
+                reply.setStatus(status);
+                return reply;
             } else {
                 db.rollback();
                 // Fix for EUCA-2782. Different exceptions are thrown based on
@@ -2837,7 +2713,7 @@ public class WalrusFSManager extends WalrusManager {
         }
     }
 
-    private String getMultipartData(DefaultHttpResponse httpResponse, ObjectInfo objectInfo, GetObjectType request, GetObjectResponseType response) throws WalrusException {
+    private String getMultipartData(ObjectInfo objectInfo, GetObjectType request, GetObjectResponseType response) throws WalrusException {
         //get all parts
         PartInfo searchPart = new PartInfo(request.getBucket(), request.getKey());
         searchPart.setCleanup(false);
@@ -2887,10 +2763,7 @@ public class WalrusFSManager extends WalrusManager {
         } else {
             response.setHasStreamingData(true);
             // support for large objects
-			storageManager.sendObject(request, httpResponse, parts, objectInfo.getSize(), objectInfo.getEtag(),
-					DateFormatter.dateToHeaderFormattedString(objectInfo.getLastModified()), objectInfo.getContentType(), objectInfo.getContentDisposition(),
-					request.getIsCompressed(), objectInfo.getVersionId());
-
+            storageManager.getMultipartObject(response, parts, request.getIsCompressed());
             return null;
         }
     }
@@ -2902,7 +2775,6 @@ public class WalrusFSManager extends WalrusManager {
                 .getReply();
         String bucketName = request.getBucket();
         Context ctx = Contexts.lookup();
-        Account account = ctx.getAccount();
 
         EntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);
         BucketInfo bucketInfo = new BucketInfo(bucketName);
@@ -3149,7 +3021,7 @@ public class WalrusFSManager extends WalrusManager {
         } else {
             bucketInfo.setLoggingEnabled(false);
         }
-    db.commit();
+        db.commit();
         return reply;
     }
 
diff --git a/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/pipeline/WalrusOutboundHandler.java b/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/pipeline/WalrusOutboundHandler.java
index 3add73b..1a7abd8 100644
--- a/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/pipeline/WalrusOutboundHandler.java
+++ b/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/pipeline/WalrusOutboundHandler.java
@@ -62,15 +62,23 @@
 
 package com.eucalyptus.walrus.pipeline;
 
+import com.eucalyptus.context.Contexts;
 import com.eucalyptus.storage.common.DateFormatter;
+import com.eucalyptus.storage.msgs.s3.MetaDataEntry;
 import com.eucalyptus.walrus.msgs.WalrusDataGetResponseType;
 import com.eucalyptus.walrus.msgs.WalrusDataResponseType;
+import com.eucalyptus.ws.WebServicesException;
+import com.eucalyptus.ws.server.Statistics;
+import com.google.common.base.Strings;
 import org.apache.log4j.Logger;
+import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelEvent;
+import org.jboss.netty.channel.ChannelFuture;
 import org.jboss.netty.channel.ChannelFutureListener;
 import org.jboss.netty.channel.ChannelHandlerContext;
-import org.jboss.netty.channel.ExceptionEvent;
+import org.jboss.netty.channel.Channels;
 import org.jboss.netty.channel.MessageEvent;
+import org.jboss.netty.handler.codec.http.DefaultHttpResponse;
 import org.jboss.netty.handler.codec.http.HttpHeaders;
 import org.jboss.netty.handler.codec.http.HttpResponseStatus;
 
@@ -90,32 +98,63 @@ import com.eucalyptus.ws.handlers.MessageStackHandler;
 import edu.ucsb.eucalyptus.msgs.BaseMessage;
 import edu.ucsb.eucalyptus.msgs.EucalyptusErrorMessageType;
 import edu.ucsb.eucalyptus.msgs.ExceptionResponseType;
-import com.eucalyptus.walrus.msgs.AbortMultipartUploadResponseType;
-import com.eucalyptus.walrus.msgs.AbortMultipartUploadType;
-import com.eucalyptus.walrus.msgs.CompleteMultipartUploadResponseType;
-import com.eucalyptus.walrus.msgs.CompleteMultipartUploadType;
-import com.eucalyptus.walrus.msgs.InitiateMultipartUploadResponseType;
-import com.eucalyptus.walrus.msgs.InitiateMultipartUploadType;
-import com.eucalyptus.walrus.msgs.UploadPartResponseType;
-import com.eucalyptus.walrus.msgs.UploadPartType;
+import org.jboss.netty.handler.codec.http.HttpVersion;
+import org.jboss.netty.handler.stream.ChunkedInput;
+
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.Callable;
 
 public class WalrusOutboundHandler extends MessageStackHandler {
-	private static Logger LOG = Logger.getLogger( WalrusOutboundHandler.class );
-
-	@Override
-	public void outgoingMessage( ChannelHandlerContext ctx, MessageEvent event ) throws Exception {
-		if ( event.getMessage( ) instanceof MappingHttpResponse ) {
-			MappingHttpResponse httpResponse = ( MappingHttpResponse ) event.getMessage( );
-			BaseMessage msg = (BaseMessage) httpResponse.getMessage( );
-
-			if(msg instanceof PutObjectResponseType) {
-				PutObjectResponseType putObjectResponse = (PutObjectResponseType) msg;
-				httpResponse.addHeader(HttpHeaders.Names.ETAG, '\"' + putObjectResponse.getEtag() + '\"');
-				httpResponse.addHeader(HttpHeaders.Names.LAST_MODIFIED, DateFormatter.dateToHeaderFormattedString(putObjectResponse.getLastModified()));
-				if(putObjectResponse.getVersionId() != null) {
-					httpResponse.addHeader(WalrusProperties.X_AMZ_VERSION_ID, putObjectResponse.getVersionId());
-				}
-			} else if(msg instanceof WalrusDataResponseType) {
+    private static Logger LOG = Logger.getLogger( WalrusOutboundHandler.class );
+
+    @Override
+    public void handleDownstream(final ChannelHandlerContext ctx, final ChannelEvent channelEvent) throws Exception {
+        try {
+            if (channelEvent instanceof MessageEvent) {
+                final MessageEvent event = (MessageEvent) channelEvent;
+                if ( event.getMessage( ) != null ) {
+                    if ( event.getMessage( ) instanceof MappingHttpResponse ) {
+                        MappingHttpResponse httpResponse = ( MappingHttpResponse ) event.getMessage( );
+                        BaseMessage msg = (BaseMessage) httpResponse.getMessage( );
+                        if (msg instanceof  WalrusDataGetResponseType) {
+                            Callable<Long> stat = Statistics.startDownstream(ctx.getChannel(), this);
+                            boolean isDone = this.handleMessage(ctx, event);
+                            stat.call();
+
+                            if (isDone) {
+                                return;
+                            }
+                            //fall through and handle other types
+                        }
+                    }
+                    //handle other types
+                    Callable<Long> stat = Statistics.startDownstream( ctx.getChannel( ), this );
+                    this.outgoingMessage(ctx, event);
+                    stat.call();
+                }
+            }
+            ctx.sendDownstream(channelEvent);
+        } catch (Exception e) {
+            //TODO: zhill - this should be a error message sent downstream
+            throw new WebServicesException(e.getMessage(), HttpResponseStatus.BAD_REQUEST);//TODO:GRZE: this is not right; needs to propagate in the right direction wrt server vs. client
+        }
+    }
+
+    @Override
+    public void outgoingMessage( ChannelHandlerContext ctx, MessageEvent event ) throws Exception {
+        if ( event.getMessage( ) instanceof MappingHttpResponse ) {
+            MappingHttpResponse httpResponse = ( MappingHttpResponse ) event.getMessage( );
+            BaseMessage msg = (BaseMessage) httpResponse.getMessage( );
+
+            if(msg instanceof PutObjectResponseType) {
+                PutObjectResponseType putObjectResponse = (PutObjectResponseType) msg;
+                httpResponse.addHeader(HttpHeaders.Names.ETAG, '\"' + putObjectResponse.getEtag() + '\"');
+                httpResponse.addHeader(HttpHeaders.Names.LAST_MODIFIED, DateFormatter.dateToHeaderFormattedString(putObjectResponse.getLastModified()));
+                if(putObjectResponse.getVersionId() != null) {
+                    httpResponse.addHeader(WalrusProperties.X_AMZ_VERSION_ID, putObjectResponse.getVersionId());
+                }
+            } else if(msg instanceof WalrusDataResponseType) {
                 WalrusDataResponseType response = (WalrusDataResponseType) msg;
                 httpResponse.addHeader(HttpHeaders.Names.ETAG, '\"' + response.getEtag() + '\"');
                 httpResponse.addHeader(HttpHeaders.Names.LAST_MODIFIED, DateFormatter.dateToHeaderFormattedString(response.getLastModified()));
@@ -123,65 +162,145 @@ public class WalrusOutboundHandler extends MessageStackHandler {
                     httpResponse.addHeader(WalrusProperties.X_AMZ_VERSION_ID, response.getVersionId());
                 }
             } else if (msg instanceof PostObjectResponseType) {
-				PostObjectResponseType postObjectResponse = (PostObjectResponseType) msg;
-				String redirectUrl = postObjectResponse.getRedirectUrl();
-				if ( redirectUrl != null ) {
-					httpResponse.addHeader(HttpHeaders.Names.LOCATION, redirectUrl);
-					httpResponse.setStatus(HttpResponseStatus.SEE_OTHER);
-					httpResponse.setMessage(null);
-				} else {
-					Integer successCode = postObjectResponse.getSuccessCode();
-					if ( successCode != null ) {
-						if(successCode != 201) {
-							httpResponse.setMessage(null);
-							httpResponse.setStatus(new HttpResponseStatus(successCode, "OK"));
-						} else {
-							httpResponse.setStatus(new HttpResponseStatus(successCode, "Created"));
-						}
-					}
-				}
-				//have to force a close for browsers
-				event.getFuture().addListener(ChannelFutureListener.CLOSE);
-			} else if(msg instanceof CopyObjectResponseType) {
-				CopyObjectResponseType copyResponse = (CopyObjectResponseType) msg;
-				if(copyResponse.getVersionId() != null)
-					httpResponse.addHeader("x-amz-version-id", copyResponse.getVersionId());
-				if(copyResponse.getCopySourceVersionId() != null)
-					httpResponse.addHeader("x-amz-copy-source-version-id", copyResponse.getCopySourceVersionId());
-			} else if(msg instanceof EucalyptusErrorMessageType) {      
-				EucalyptusErrorMessageType errorMessage = (EucalyptusErrorMessageType) msg;
-				BaseMessage errMsg = WalrusUtil.convertErrorMessage(errorMessage);
-				if(errMsg instanceof WalrusErrorMessageType) {
-					WalrusErrorMessageType walrusErrorMsg = (WalrusErrorMessageType) errMsg;
-					httpResponse.setStatus(walrusErrorMsg.getStatus());
-				}
-				httpResponse.setMessage(errMsg);
-			} else if(msg instanceof ExceptionResponseType) {      
-				ExceptionResponseType errorMessage = (ExceptionResponseType) msg;
-				BaseMessage errMsg = WalrusUtil.convertErrorMessage(errorMessage);
-				if(errMsg instanceof WalrusErrorMessageType) {
-					WalrusErrorMessageType walrusErrorMsg = (WalrusErrorMessageType) errMsg;
-					httpResponse.setStatus(walrusErrorMsg.getStatus());
-				}
-				// Fix for EUCA-2782. If the exception occurred on HEAD request, http response body should be empty
-				if(errorMessage.getException() instanceof HeadExceptionInterface) {
-					httpResponse.setMessage(null);
-				} else {
-					httpResponse.setMessage(errMsg);	
-				}
-			} else if (msg instanceof WalrusDeleteResponseType) {
-				httpResponse.setStatus(HttpResponseStatus.NO_CONTENT);
-				httpResponse.setMessage(null);
-			} else if (msg instanceof WalrusHeadResponseType) {
-				//This is a HEAD request, don't put a body
-				httpResponse.setStatus(HttpResponseStatus.OK);
-				httpResponse.setMessage(null);
-			} else if (msg instanceof CreateBucketResponseType) {
-				httpResponse.setStatus(HttpResponseStatus.OK);
-				httpResponse.setMessage(null);
-				event.getFuture().addListener(ChannelFutureListener.CLOSE);
-			} 
-		}
-	}
+                PostObjectResponseType postObjectResponse = (PostObjectResponseType) msg;
+                String redirectUrl = postObjectResponse.getRedirectUrl();
+                if ( redirectUrl != null ) {
+                    httpResponse.addHeader(HttpHeaders.Names.LOCATION, redirectUrl);
+                    httpResponse.setStatus(HttpResponseStatus.SEE_OTHER);
+                    httpResponse.setMessage(null);
+                } else {
+                    Integer successCode = postObjectResponse.getSuccessCode();
+                    if ( successCode != null ) {
+                        if(successCode != 201) {
+                            httpResponse.setMessage(null);
+                            httpResponse.setStatus(new HttpResponseStatus(successCode, "OK"));
+                        } else {
+                            httpResponse.setStatus(new HttpResponseStatus(successCode, "Created"));
+                        }
+                    }
+                }
+                //have to force a close for browsers
+                event.getFuture().addListener(ChannelFutureListener.CLOSE);
+            } else if(msg instanceof CopyObjectResponseType) {
+                CopyObjectResponseType copyResponse = (CopyObjectResponseType) msg;
+                if(copyResponse.getVersionId() != null)
+                    httpResponse.addHeader("x-amz-version-id", copyResponse.getVersionId());
+                if(copyResponse.getCopySourceVersionId() != null)
+                    httpResponse.addHeader("x-amz-copy-source-version-id", copyResponse.getCopySourceVersionId());
+            } else if(msg instanceof EucalyptusErrorMessageType) {
+                EucalyptusErrorMessageType errorMessage = (EucalyptusErrorMessageType) msg;
+                BaseMessage errMsg = WalrusUtil.convertErrorMessage(errorMessage);
+                if(errMsg instanceof WalrusErrorMessageType) {
+                    WalrusErrorMessageType walrusErrorMsg = (WalrusErrorMessageType) errMsg;
+                    httpResponse.setStatus(walrusErrorMsg.getStatus());
+                }
+                httpResponse.setMessage(errMsg);
+            } else if(msg instanceof ExceptionResponseType) {
+                ExceptionResponseType errorMessage = (ExceptionResponseType) msg;
+                BaseMessage errMsg = WalrusUtil.convertErrorMessage(errorMessage);
+                if(errMsg instanceof WalrusErrorMessageType) {
+                    WalrusErrorMessageType walrusErrorMsg = (WalrusErrorMessageType) errMsg;
+                    httpResponse.setStatus(walrusErrorMsg.getStatus());
+                }
+                // Fix for EUCA-2782. If the exception occurred on HEAD request, http response body should be empty
+                if(errorMessage.getException() instanceof HeadExceptionInterface) {
+                    httpResponse.setMessage(null);
+                } else {
+                    httpResponse.setMessage(errMsg);
+                }
+            } else if (msg instanceof WalrusDeleteResponseType) {
+                httpResponse.setStatus(HttpResponseStatus.NO_CONTENT);
+                httpResponse.setMessage(null);
+            } else if (msg instanceof WalrusHeadResponseType) {
+                //This is a HEAD request, don't put a body
+                httpResponse.setStatus(HttpResponseStatus.OK);
+                httpResponse.setMessage(null);
+            } else if (msg instanceof CreateBucketResponseType) {
+                httpResponse.setStatus(HttpResponseStatus.OK);
+                httpResponse.setMessage(null);
+                event.getFuture().addListener(ChannelFutureListener.CLOSE);
+            }
+        }
+    }
+
+    public boolean handleMessage(ChannelHandlerContext ctx, MessageEvent event) throws Exception {
+        return handleOutgoingMessage(ctx, event);
+    }
+
+    protected boolean handleOutgoingMessage(ChannelHandlerContext ctx, MessageEvent event) throws Exception {
+        if (event.getMessage() instanceof MappingHttpResponse) {
+            MappingHttpResponse httpResponse = (MappingHttpResponse) event.getMessage();
+            BaseMessage msg = (BaseMessage) httpResponse.getMessage();
+
+            if (msg instanceof WalrusDataGetResponseType) {
+                WalrusDataGetResponseType dataResponse = (WalrusDataGetResponseType) msg;
+                writeObjectStorageDataGetResponse(dataResponse, ctx);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    protected void writeObjectStorageDataGetResponse(final WalrusDataGetResponseType response, final ChannelHandlerContext ctx) {
+        DefaultHttpResponse httpResponse = createHttpResponse(response);
+        if (!Strings.isNullOrEmpty(response.getCorrelationId())) {
+            httpResponse.setHeader(WalrusProperties.AMZ_REQUEST_ID, response.getCorrelationId());
+        }
+
+        final Channel channel = ctx.getChannel();
+        if (channel.isWritable()) {
+            ChannelFuture writeFuture = Channels.future(ctx.getChannel());
+            Channels.write(ctx, writeFuture, httpResponse);
+            List<ChunkedInput> dataStreams = response.getDataInputStream();
+            if (dataStreams != null) {
+                for (final ChunkedInput dataStream : dataStreams) {
+                    channel.write(dataStream).addListener(new ChannelFutureListener( ) {
+                        @Override public void operationComplete( ChannelFuture future ) throws Exception {
+                            dataStream.close();
+                        }
+                    });
+                }
+            } else {
+                writeFuture.addListener(ChannelFutureListener.CLOSE);
+            }
+        }
+    }
+
+    //TODO: zhill - this should all be done in bindings, just need 2-way bindings
+    protected DefaultHttpResponse createHttpResponse(WalrusDataGetResponseType reply) {
+        DefaultHttpResponse httpResponse = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
+        long contentLength = reply.getSize();
+        String contentType = reply.getContentType();
+        String etag = reply.getEtag();
+        String contentDisposition = reply.getContentDisposition();
+        httpResponse.addHeader(HttpHeaders.Names.CONTENT_TYPE, contentType != null ? contentType : "binary/octet-stream");
+        if (etag != null) {
+            httpResponse.addHeader(HttpHeaders.Names.ETAG, "\"" + etag + "\""); //etag in quotes, per s3-spec.
+        }
+        httpResponse.addHeader(HttpHeaders.Names.LAST_MODIFIED, DateFormatter.dateToHeaderFormattedString(reply.getLastModified()));
+
+        if (contentDisposition != null) {
+            httpResponse.addHeader("Content-Disposition", contentDisposition);
+        }
+        String versionId = reply.getVersionId();
+        if (versionId != null && !WalrusProperties.NULL_VERSION_ID.equals(versionId)) {
+            httpResponse.addHeader(WalrusProperties.X_AMZ_VERSION_ID, versionId);
+        }
+        httpResponse.setHeader(HttpHeaders.Names.DATE, DateFormatter.dateToHeaderFormattedString(new Date()));
+
+        //Add user metadata
+        for (MetaDataEntry m : reply.getMetaData()) {
+            httpResponse.addHeader(WalrusProperties.AMZ_META_HEADER_PREFIX + m.getName(), m.getValue());
+        }
+
+        //write extra headers
+        if (reply.getByteRangeEnd() != null && reply.getByteRangeStart() != null) {
+            httpResponse.addHeader("Content-Range", reply.getByteRangeStart() + "-" + reply.getByteRangeEnd() + "/" + reply.getSize());
+            httpResponse.addHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(reply.getByteRangeEnd() - reply.getByteRangeStart()));
+        } else {
+            httpResponse.addHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(contentLength));
+        }
+        return httpResponse;
+    }
 
 }
diff --git a/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/storage/FileSystemStorageManager.java b/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/storage/FileSystemStorageManager.java
index f889afe..20d4152 100644
--- a/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/storage/FileSystemStorageManager.java
+++ b/clc/modules/walrus/src/main/java/com/eucalyptus/walrus/storage/FileSystemStorageManager.java
@@ -71,9 +71,12 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.channels.FileChannel;
+import java.util.ArrayList;
 import java.util.List;
 
 import com.eucalyptus.walrus.entities.PartInfo;
+import com.eucalyptus.walrus.exceptions.WalrusException;
+import com.eucalyptus.walrus.msgs.WalrusDataGetResponseType;
 import org.apache.log4j.Logger;
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFuture;
@@ -319,116 +322,6 @@ public class FileSystemStorageManager implements StorageManager {
         return -1;
     }
 
-    public void sendObject(final WalrusDataGetRequestType request, DefaultHttpResponse httpResponse, String bucketName, String objectName, long size, String etag, String lastModified, String contentType, String contentDisposition, Boolean isCompressed, String versionId, final BucketLogData logData) {
-        try {
-            Channel channel = request.getChannel();
-            RandomAccessFile raf = new RandomAccessFile(new File(getObjectPath(bucketName, objectName)), "r");
-            httpResponse.addHeader( HttpHeaders.Names.CONTENT_TYPE, contentType != null ? contentType : "binary/octet-stream" );
-            if(etag != null)
-                httpResponse.addHeader(HttpHeaders.Names.ETAG, etag);
-            httpResponse.addHeader(HttpHeaders.Names.LAST_MODIFIED, lastModified);
-            if(contentDisposition != null)
-                httpResponse.addHeader("Content-Disposition", contentDisposition);
-            final ChunkedInput file;
-            isCompressed = isCompressed == null ? false : isCompressed;
-            if(isCompressed) {
-                file = new CompressedChunkedFile(raf, size);
-            } else {
-                file = new ChunkedDataFile(raf, 0, size, 8192);
-                httpResponse.addHeader( HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(size));
-            }
-            if(logData != null) {
-                logData.setTurnAroundTime(System.currentTimeMillis() - logData.getTurnAroundTime());
-                logData.setBytesSent(size);
-            }
-            if(versionId != null) {
-                httpResponse.addHeader(WalrusProperties.X_AMZ_VERSION_ID, versionId);
-            }
-            channel.write(httpResponse);
-            channel.write(file).addListener(new ChannelFutureListener( ) {
-                @Override public void operationComplete( ChannelFuture future ) throws Exception {
-                    Contexts.clear(request.getCorrelationId());
-                    file.close();
-                    if(logData != null) {
-                        logData.setTotalTime(System.currentTimeMillis() - logData.getTotalTime());
-                        WalrusBucketLogger.getInstance().addLogEntry(logData);
-                    }
-                }
-            });
-        } catch(Exception ex) {
-            LOG.error(ex, ex);
-        }
-    }
-
-    public void sendObject(final WalrusDataGetRequestType request, DefaultHttpResponse httpResponse, String bucketName, String objectName, long start, long end, long size, String etag, String lastModified, String contentType, String contentDisposition, Boolean isCompressed, String versionId, final BucketLogData logData) {
-        try {
-            Channel channel = request.getChannel();
-            RandomAccessFile raf = new RandomAccessFile(new File(getObjectPath(bucketName, objectName)), "r");
-            httpResponse.addHeader( HttpHeaders.Names.CONTENT_TYPE, contentType != null ? contentType : "binary/octet-stream" );
-            if(etag != null)
-                httpResponse.addHeader(HttpHeaders.Names.ETAG, etag);
-            httpResponse.addHeader(HttpHeaders.Names.LAST_MODIFIED, lastModified);
-            if(contentDisposition != null)
-                httpResponse.addHeader("Content-Disposition", contentDisposition);
-            final ChunkedInput file;
-            isCompressed = isCompressed == null ? false : isCompressed;
-            if(isCompressed) {
-                file = new CompressedChunkedFile(raf, start, end, (int)Math.min((end - start), 8192));
-            } else {
-                file = new ChunkedDataFile(raf, start, (int)(end - start), (int)Math.min((end - start), 8192));
-                httpResponse.addHeader( HttpHeaders.Names.CONTENT_LENGTH, String.valueOf((end - start)));
-            }
-            httpResponse.addHeader("Content-Range", start + "-" + (end -1) + "/" + size);
-            if(logData != null) {
-                logData.setTurnAroundTime(System.currentTimeMillis() - logData.getTurnAroundTime());
-                logData.setBytesSent(size);
-            }
-            if(versionId != null) {
-                httpResponse.addHeader(WalrusProperties.X_AMZ_VERSION_ID, versionId);
-            }
-            channel.write(httpResponse);
-            channel.write(file).addListener(new ChannelFutureListener( ) {
-                @Override public void operationComplete( ChannelFuture future ) throws Exception {
-                    Contexts.clear(request.getCorrelationId());
-                    file.close();
-                    if(logData != null) {
-                        logData.setTotalTime(System.currentTimeMillis() - logData.getTotalTime());
-                        WalrusBucketLogger.getInstance().addLogEntry(logData);
-                    }
-                }
-            });
-        } catch(Exception ex) {
-            LOG.error(ex, ex);
-        }
-    }
-
-    public void sendHeaders(final WalrusDataGetRequestType request, DefaultHttpResponse httpResponse, Long size, String etag,
-                            String lastModified, String contentType, String contentDisposition, String versionId, final BucketLogData logData) {
-        Channel channel = request.getChannel();
-        httpResponse.addHeader( HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(size));
-        httpResponse.addHeader( HttpHeaders.Names.CONTENT_TYPE, contentType != null ? contentType : "binary/octet-stream" );
-        if(etag != null)
-            httpResponse.addHeader(HttpHeaders.Names.ETAG, etag);
-        httpResponse.addHeader(HttpHeaders.Names.LAST_MODIFIED, lastModified);
-        if(contentDisposition != null)
-            httpResponse.addHeader("Content-Disposition", contentDisposition);
-        if(versionId != null) {
-            httpResponse.addHeader(WalrusProperties.X_AMZ_VERSION_ID, versionId);
-        }
-        if(logData != null) {
-            logData.setTurnAroundTime(System.currentTimeMillis() - logData.getTurnAroundTime());
-        }
-        channel.write(httpResponse).addListener(new ChannelFutureListener( ) {
-            @Override public void operationComplete( ChannelFuture future ) throws Exception {
-                Contexts.clear(request.getCorrelationId());
-                if(logData != null) {
-                    logData.setTotalTime(System.currentTimeMillis() - logData.getTotalTime());
-                    WalrusBucketLogger.getInstance().addLogEntry(logData);
-                }
-            }
-        });
-    }
-
     private String removeLoopback(String loDevName) throws EucalyptusCloudException {
         return SystemUtil.run(new String[]{EUCA_ROOT_WRAPPER, "losetup", "-d", loDevName});
     }
@@ -541,21 +434,47 @@ public class FileSystemStorageManager implements StorageManager {
     }
 
     @Override
-    public void sendObject(final WalrusDataGetRequestType request, DefaultHttpResponse httpResponse, List<PartInfo> parts, Long size, String etag, String lastModified, String contentType, String contentDisposition, Boolean isCompressed, String versionId) {
+    public void getObject(String bucketName, String objectName, final WalrusDataGetResponseType response, Long size, Boolean isCompressed) throws WalrusException {
         try {
-            Channel channel = request.getChannel();
-            httpResponse.addHeader( HttpHeaders.Names.CONTENT_TYPE, contentType != null ? contentType : "binary/octet-stream" );
-            if(etag != null)
-                httpResponse.addHeader(HttpHeaders.Names.ETAG, etag);
-            httpResponse.addHeader(HttpHeaders.Names.LAST_MODIFIED, lastModified);
-            if(contentDisposition != null)
-                httpResponse.addHeader("Content-Disposition", contentDisposition);
-            if(versionId != null) {
-                httpResponse.addHeader(WalrusProperties.X_AMZ_VERSION_ID, versionId);
+            RandomAccessFile raf = new RandomAccessFile(new File(getObjectPath(bucketName, objectName)), "r");
+            final ChunkedInput file;
+            isCompressed = isCompressed == null ? false : isCompressed;
+            if(isCompressed) {
+                file = new CompressedChunkedFile(raf, size);
+            } else {
+                file = new ChunkedDataFile(raf, 0, size, 8192);
             }
-            httpResponse.addHeader( HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(size));
-            channel.write(httpResponse);
+            List<ChunkedInput> dataStreams = new ArrayList<ChunkedInput>();
+            dataStreams.add(file);
+            response.setDataInputStream(dataStreams);
+        } catch (IOException ex) {
+            throw new WalrusException(ex.getMessage());
+        }
+    }
 
+    @Override
+    public void getObject(String bucketName, String objectName, final WalrusDataGetResponseType response, Long byteRangeStart, Long byteRangeEnd, Boolean isCompressed) throws WalrusException {
+        try {
+            RandomAccessFile raf = new RandomAccessFile(new File(getObjectPath(bucketName, objectName)), "r");
+            final ChunkedInput file;
+            isCompressed = isCompressed == null ? false : isCompressed;
+            if(isCompressed) {
+                file = new CompressedChunkedFile(raf, byteRangeStart, byteRangeEnd, (int)Math.min((byteRangeEnd - byteRangeStart), 8192));
+            } else {
+                file = new ChunkedDataFile(raf, byteRangeStart, (int)(byteRangeEnd - byteRangeStart), (int)Math.min((byteRangeEnd - byteRangeStart), 8192));
+            }
+            List<ChunkedInput> dataStreams = new ArrayList<>();
+            dataStreams.add(file);
+            response.setDataInputStream(dataStreams);
+        } catch (IOException ex) {
+            throw new WalrusException(ex.getMessage());
+        }
+    }
+
+    @Override
+    public void getMultipartObject(WalrusDataGetResponseType reply, List<PartInfo> parts, Boolean isCompressed) throws WalrusException {
+        try {
+            List<ChunkedInput> dataStreams = new ArrayList<>();
             for (PartInfo part : parts) {
                 isCompressed = isCompressed == null ? false : isCompressed;
                 final ChunkedInput file;
@@ -565,14 +484,11 @@ public class FileSystemStorageManager implements StorageManager {
                 } else {
                     file = new ChunkedDataFile(raf, 0, part.getSize(), 8192);
                 }
-                channel.write(file).addListener(new ChannelFutureListener( ) {
-                    @Override public void operationComplete( ChannelFuture future ) throws Exception {
-                        file.close();
-                    }
-                });
+                dataStreams.add(file);
             }
-        } catch(Exception ex) {
-            LOG.error(ex, ex);
+            reply.setDataInputStream(dataStreams);
+        } catch (IOException ex) {
+            throw new WalrusException(ex.getMessage());
         }
     }
 
