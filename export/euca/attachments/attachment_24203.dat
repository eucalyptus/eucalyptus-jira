/*************************************************************************
 * Copyright 2009-2015 Eucalyptus Systems, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/.
 *
 * Please contact Eucalyptus Systems, Inc., 6755 Hollister Ave., Goleta
 * CA 93117, USA or visit http://www.eucalyptus.com/licenses/ if you need
 * additional information or have any questions.
 ************************************************************************/
package com.eucalyptus.tests.awssdk

import com.amazonaws.auth.AWSCredentialsProvider
import com.amazonaws.auth.BasicAWSCredentials
import com.amazonaws.internal.StaticCredentialsProvider
import com.amazonaws.regions.Region
import com.amazonaws.regions.Regions
import com.amazonaws.services.ec2.AmazonEC2
import com.amazonaws.services.ec2.AmazonEC2Client
import com.amazonaws.services.ec2.model.*
import com.amazonaws.services.elasticloadbalancing.AmazonElasticLoadBalancing
import com.amazonaws.services.elasticloadbalancing.AmazonElasticLoadBalancingClient
import com.amazonaws.services.elasticloadbalancing.model.*
import com.amazonaws.services.identitymanagement.AmazonIdentityManagement
import com.amazonaws.services.identitymanagement.AmazonIdentityManagementClient
import com.amazonaws.services.identitymanagement.model.DeleteServerCertificateRequest
import com.amazonaws.services.identitymanagement.model.UploadServerCertificateRequest
import com.amazonaws.util.Base64

import javax.net.ssl.HostnameVerifier
import javax.net.ssl.HttpsURLConnection
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSession
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager
import java.nio.charset.StandardCharsets
import java.security.cert.Certificate
import java.security.cert.CertificateException
import java.security.cert.CertificateFactory
import java.security.cert.X509Certificate

/**
 *
 */
class TestELBEC2ClassicSSLFront {

  private final String host;
  private final AWSCredentialsProvider credentials;

  public static void main( String[] args ) throws Exception {
    new TestELBEC2ClassicSSLFront( '127.0.0.1', 'AKI...', 'uhu...' ).test( )
  }

  public TestELBEC2ClassicSSLFront( String host,
                                    String accessKey,
                                    String secretKey ) {
    this.host = host
    this.credentials = new StaticCredentialsProvider( new BasicAWSCredentials( accessKey, secretKey ) )
  }

  private String cloudUri( String servicePath ) {
    URI.create( "http://" + host + ":8773/" )
        .resolve( servicePath )
        .toString()
  }

  private AmazonEC2 getEC2Client( final AWSCredentialsProvider credentials ) {
    final AmazonEC2 ec2 = new AmazonEC2Client( credentials )
    if ( host ) {
      ec2.setEndpoint( cloudUri( "/services/compute" ) )
    } else {
      ec2.setRegion(Region.getRegion( Regions.US_WEST_1 ) )
    }
    ec2
  }

  private AmazonElasticLoadBalancing getELBClient( final AWSCredentialsProvider credentials ) {
    final AmazonElasticLoadBalancing elb = new AmazonElasticLoadBalancingClient( credentials )
    if ( host ) {
      elb.setEndpoint( cloudUri( "/services/LoadBalancing" ) )
    } else {
      elb.setRegion(Region.getRegion( Regions.US_WEST_1 ) )
    }
    elb
  }

  private AmazonIdentityManagement getIAMClient( final AWSCredentialsProvider credentials  ) {
    final AmazonIdentityManagementClient iam = new AmazonIdentityManagementClient( credentials )
    if ( host ) {
      iam.setEndpoint( cloudUri( "/services/Euare" ) )
    }
    iam
  }

  private boolean assertThat( boolean condition,
                              String message ){
    assert condition : message
    true
  }

  private void print( String text ) {
    System.out.println( text )
  }

  public void test( ) throws Exception {
    final AmazonEC2 ec2 = getEC2Client( credentials )

    // Find an AZ to use
    final DescribeAvailabilityZonesResult azResult = ec2.describeAvailabilityZones();

    assertThat( azResult.getAvailabilityZones().size() > 0, "Availability zone not found" );

    final String availabilityZone = azResult.getAvailabilityZones().get( 0 ).getZoneName();
    print( "Using availability zone: " + availabilityZone );

    final String namePrefix = UUID.randomUUID().toString().substring(0, 13) + "-";
    print( "Using resource prefix for test: " + namePrefix );

    final AmazonElasticLoadBalancing elb = getELBClient( credentials )
    final List<Runnable> cleanupTasks = [] as List<Runnable>
    try {
      String certPem = '''\
            -----BEGIN CERTIFICATE-----
            MIIDDDCCAfSgAwIBAgIQM6YEf7FVYx/tZyEXgVComTANBgkqhkiG9w0BAQUFADAw
            MQ4wDAYDVQQKDAVPQVNJUzEeMBwGA1UEAwwVT0FTSVMgSW50ZXJvcCBUZXN0IENB
            MB4XDTA1MDMxOTAwMDAwMFoXDTE4MDMxOTIzNTk1OVowQjEOMAwGA1UECgwFT0FT
            SVMxIDAeBgNVBAsMF09BU0lTIEludGVyb3AgVGVzdCBDZXJ0MQ4wDAYDVQQDDAVB
            bGljZTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAoqi99By1VYo0aHrkKCNT
            4DkIgPL/SgahbeKdGhrbu3K2XG7arfD9tqIBIKMfrX4Gp90NJa85AV1yiNsEyvq+
            mUnMpNcKnLXLOjkTmMCqDYbbkehJlXPnaWLzve+mW0pJdPxtf3rbD4PS/cBQIvtp
            jmrDAU8VsZKT8DN5Kyz+EZsCAwEAAaOBkzCBkDAJBgNVHRMEAjAAMDMGA1UdHwQs
            MCowKKImhiRodHRwOi8vaW50ZXJvcC5iYnRlc3QubmV0L2NybC9jYS5jcmwwDgYD
            VR0PAQH/BAQDAgSwMB0GA1UdDgQWBBQK4l0TUHZ1QV3V2QtlLNDm+PoxiDAfBgNV
            HSMEGDAWgBTAnSj8wes1oR3WqqqgHBpNwkkPDzANBgkqhkiG9w0BAQUFAAOCAQEA
            BTqpOpvW+6yrLXyUlP2xJbEkohXHI5OWwKWleOb9hlkhWntUalfcFOJAgUyH30TT
            pHldzx1+vK2LPzhoUFKYHE1IyQvokBN2JjFO64BQukCKnZhldLRPxGhfkTdxQgdf
            5rCK/wh3xVsZCNTfuMNmlAM6lOAg8QduDah3WFZpEA0s2nwQaCNQTNMjJC8tav1C
            Br6+E5FAmwPXP7pJxn9Fw9OXRyqbRA4v2y7YpbGkG2GI9UvOHw6SGvf4FRSthMMO
            35YbpikGsLix3vAsXWWi4rwfVOYzQK0OFPNi9RMCUdSH06m9uLWckiCxjos0FQOD
            ZE9l4ATGy9s9hNVwryOJTw==
            -----END CERTIFICATE-----'''.stripIndent( )

      Certificate cert =
          CertificateFactory.getInstance( "X.509" ).generateCertificate( new ByteArrayInputStream( certPem.getBytes( StandardCharsets.UTF_8 ) ) )

      String sslCertificateArn = ''
      getIAMClient( credentials ).with {
        final String sslCertificateName = "${namePrefix}server-certificate1"
        print( "Uploading server certificate: ${sslCertificateName}" )
        sslCertificateArn = uploadServerCertificate( new UploadServerCertificateRequest(
          path: '/',
          serverCertificateName: sslCertificateName,
          certificateBody: certPem,
          privateKey: '''\
            -----BEGIN RSA PRIVATE KEY-----
            MIICXAIBAAKBgQCiqL30HLVVijRoeuQoI1PgOQiA8v9KBqFt4p0aGtu7crZcbtqt
            8P22ogEgox+tfgan3Q0lrzkBXXKI2wTK+r6ZScyk1wqctcs6OROYwKoNhtuR6EmV
            c+dpYvO976ZbSkl0/G1/etsPg9L9wFAi+2mOasMBTxWxkpPwM3krLP4RmwIDAQAB
            AoGAY+fazB357rE1YVrh2hlgwh6lr3YRASmzaye+MLOAdNCPW5Sm8iFL5Cn7IU2v
            /kKi2eW21oeaLtFzsMU9W2LJP6h33caPcMr/1F3wsiHRCBSZiRLgroYnryJ2pWRq
            B8r6/j1mCKzNkoxwspUS1tPFIT0yJB4L/bQGMIvnoM4v5aECQQDX2hBKRbsQYSgL
            xZmqx/KJG7+rcpjYXBcztcO09sAsJ+tJe7FPKoKB1CG/KWqj8KQn69blXxhKRDTp
            rPZLiU7RAkEAwOnfR+dwLbnNGTuafvvbWE1d0CCa3YGooCrrCq4Af7D5jv9TZXDx
            yOIZsHzQH5U47e9ht2JvYllbTlMhirKsqwJBAKbyAadwRz5j5pU0P6XW/78LtzLj
            b1Pn5goYi0VrkzaTqWcsQ/b26fmAGJnBbrldZZl6zrqY0jCekE4reFLz4AECQA7Y
            MEFFMuGh4YFmj73jvX4u/eANEj2nQ4WHp+x7dTheMuXpCc7NgR13IIjvIci8X9QX
            Toqg/Xcw7xC43uTgWN8CQF2p4WulNa6U64sxyK1gBWOr6kwx6PWU29Ay6MPDPAJP
            O84lDgb5dlC1SGE+xHUzPPN6E4YFI/ECawOHNrADEsE=
            -----END RSA PRIVATE KEY-----
            '''.stripIndent( )
        ) ).with {
          serverCertificateMetadata.arn
        }
        print( "Created server certificate: ${sslCertificateArn}" )
        cleanupTasks.add {
          print( "Deleting server certificate: ${sslCertificateName}" )
          deleteServerCertificate( new DeleteServerCertificateRequest( serverCertificateName: sslCertificateName ) )
        }
      }

      elb.with {
        String loadBalancerName = "${namePrefix}balancer1"
        print( "Creating load balancer: ${loadBalancerName}" )
        createLoadBalancer( new CreateLoadBalancerRequest(
            loadBalancerName: loadBalancerName,
            listeners: [ new Listener(
                loadBalancerPort: 9999,
                protocol: 'HTTPS',
                instancePort: 9999,
                instanceProtocol: 'HTTP',
                sSLCertificateId: sslCertificateArn
            ) ],
            availabilityZones: [ availabilityZone ]
        ) )
        cleanupTasks.add {
          print( "Deleting load balancer: ${loadBalancerName}" )
          deleteLoadBalancer( new DeleteLoadBalancerRequest( loadBalancerName: loadBalancerName ) )
        }

        println( "Created load balancer: ${loadBalancerName}" )
        String balancerHost = describeLoadBalancers( new DescribeLoadBalancersRequest( loadBalancerNames: [ loadBalancerName ] ) ).with {
          println( loadBalancerDescriptions.toString( ) )
          assertThat( loadBalancerDescriptions.size( ) == 1, "Expected one load balancer, but was: ${loadBalancerDescriptions.size( )}" )
          loadBalancerDescriptions.get( 0 ).with {
            assertThat( loadBalancerName == it.loadBalancerName, "Expected name ${loadBalancerName}, but was: ${it.loadBalancerName}" )
            assertThat( scheme == 'internet-facing', "Expected scheme internet-facing, but was: ${scheme}" )
            assertThat( VPCId == null, "Expected no vpc, but was: ${VPCId}" )
            assertThat( subnets == null || subnets.isEmpty( ), "Expected no subnets, but was: ${subnets}" )
            assertThat( securityGroups == null || securityGroups.isEmpty( ), "Expected no (VPC) security groups, but was: ${securityGroups}" )
            assertThat( availabilityZones == [ availabilityZone ], "Expected zones [ ${availabilityZone} ], but was: ${availabilityZones}" )
            assertThat( sourceSecurityGroup != null, "Expected source security group")
            sourceSecurityGroup.with {
              ec2.with {
                String authGroupName = "${namePrefix}elb-source-group-auth-test"
                println( "Creating security group to test elb source group authorization: ${authGroupName}" )
                String authGroupId = createSecurityGroup( new CreateSecurityGroupRequest(
                    groupName: authGroupName,
                    description: 'Test security group for validation of ELB source group authorization'
                ) ).with {
                  groupId
                }
                println( "Created security group ${authGroupName}, with id ${authGroupId}" )
                cleanupTasks.add{
                  println( "Deleting security group: ${authGroupName}/${authGroupId}" )
                  deleteSecurityGroup( new DeleteSecurityGroupRequest(
                      groupId: authGroupId
                  ) )
                }
                println( "Authorizing elb source group ${ownerAlias}/${groupName} for ${authGroupName}/${authGroupId}" )
                authorizeSecurityGroupIngress( new AuthorizeSecurityGroupIngressRequest(
                  groupId: authGroupId,
                  ipPermissions: [
                      new IpPermission(
                          ipProtocol: 'tcp',
                          fromPort: 9999,
                          toPort: 9999,
                          userIdGroupPairs: [
                              new UserIdGroupPair(
                                  userId: ownerAlias,
                                  groupName: groupName
                              )
                          ]
                      )
                  ]
                ))
              }
            }
            DNSName
          }
        }

        // test running an instance with an HTTP service
        if ( host ) ec2.with{
          // Find an image to use
          final String imageId = describeImages( new DescribeImagesRequest(
              filters: [
                  new Filter( name: "image-type", values: ["machine"] ),
                  new Filter( name: "root-device-type", values: ["instance-store"] ),
                  new Filter( name: "is-public", values: ["true"] ),
              ]
          ) ).with {
            images?.getAt( 0 )?.imageId
          }
          assertThat( imageId != null , "Image not found" )
          print( "Using image: ${imageId}" )

          // Discover SSH key
          final String keyName = describeKeyPairs( ).with {
            keyPairs?.getAt(0)?.keyName
          }
          print( "Using key pair: " + keyName )

          String instanceSecurityGroup = "${namePrefix}instance-group"
          print( "Creating security group with name: ${instanceSecurityGroup}" )
          String instanceGroupId = createSecurityGroup( new CreateSecurityGroupRequest(
            groupName: instanceSecurityGroup,
            description: 'Test security group for instances'
          ) ).with {
            groupId
          }
          cleanupTasks.add {
            println("Deleting security group: ${instanceSecurityGroup}/${instanceGroupId}")
            deleteSecurityGroup(new DeleteSecurityGroupRequest(
                groupId: instanceGroupId
            ))
          }

          println( "Authorizing instance security group ${instanceSecurityGroup}/${instanceGroupId}" )
          authorizeSecurityGroupIngress( new AuthorizeSecurityGroupIngressRequest(
              groupId: instanceGroupId,
              ipPermissions: [
                  new IpPermission(
                      ipProtocol: 'tcp',
                      fromPort: 22,
                      toPort: 22,
                      ipRanges: [ '0.0.0.0/0' ]
                  ),
                  new IpPermission(
                      ipProtocol: 'tcp',
                      fromPort: 9999,
                      toPort: 9999,
                      ipRanges: [ '0.0.0.0/0' ]
                  ),
              ]
          ))

          String userDataText = '''
          #!/usr/bin/python -tt
          import SimpleHTTPServer, BaseHTTPServer

          class StaticHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
            def do_GET(self):
              self.send_response( 200 )
              self.send_header('Content-Type', 'text/plain; charset=utf-8')
              self.end_headers( )
              self.wfile.write("Hello")
              self.wfile.close( );

          BaseHTTPServer.HTTPServer( ("", 9999), StaticHandler ).serve_forever( )
          '''.stripIndent( ).trim( )

          print( "Running instance to access via load balancer ${loadBalancerName}" )
          String instanceId = runInstances( new RunInstancesRequest(
              minCount: 1,
              maxCount: 1,
              imageId: imageId,
              keyName: keyName,
              securityGroupIds: [ instanceGroupId ],
              userData: Base64.encodeAsString( userDataText.getBytes( StandardCharsets.UTF_8 ) )
          )).with {
            reservation?.with {
              instances?.getAt( 0 )?.instanceId
            }
          }

          print( "Instance running with identifier ${instanceId}" )
          cleanupTasks.add{
            print( "Terminating instance ${instanceId}" )
            terminateInstances( new TerminateInstancesRequest( instanceIds: [ instanceId ] ) )

            print( "Waiting for instance ${instanceId} to terminate" )
            ( 1..25 ).find{
              sleep 5000
              print( "Waiting for instance ${instanceId} to terminate, waited ${it*5}s" )
              describeInstances( new DescribeInstancesRequest(
                  instanceIds: [ instanceId ],
                  filters: [ new Filter( name: "instance-state-name", values: [ "terminated" ] ) ]
              ) ).with {
                reservations?.getAt( 0 )?.instances?.getAt( 0 )?.instanceId == instanceId
              }
            }
          }

          String instancePublicIp;
          print( "Waiting for instance ${instanceId} to start" )
          ( 1..25 ).find{
            sleep 5000
            print( "Waiting for instance ${instanceId} to start, waited ${it*5}s" )
            describeInstances( new DescribeInstancesRequest(
                instanceIds: [ instanceId ],
                filters: [ new Filter( name: "instance-state-name", values: [ "running" ] ) ]
            ) ).with {
              instancePublicIp = reservations?.getAt( 0 )?.instances?.getAt( 0 )?.publicIpAddress
              reservations?.getAt( 0 )?.instances?.getAt( 0 )?.instanceId == instanceId
            }
          }
          assertThat( instancePublicIp != null, "Expected instance public ip" )

          print( "Registering instance ${instanceId} with load balancer ${loadBalancerName}" )
          registerInstancesWithLoadBalancer( new RegisterInstancesWithLoadBalancerRequest(
            loadBalancerName: loadBalancerName,
            instances: [ new com.amazonaws.services.elasticloadbalancing.model.Instance( instanceId ) ]
          ) )

          print( "Waiting for instance ${instanceId} to be healthy" )
          ( 1..50 ).find{
            sleep 5000
            print( "Waiting for instance ${instanceId} to be healthy, waited ${it*5}s" )
            describeInstanceHealth( new DescribeInstanceHealthRequest(
                loadBalancerName: loadBalancerName,
                instances: [ new com.amazonaws.services.elasticloadbalancing.model.Instance( instanceId ) ]
            ) ).with {
              'InService' == instanceStates?.getAt( 0 )?.state
            }
          }

          describeInstanceHealth( new DescribeInstanceHealthRequest(
              loadBalancerName: loadBalancerName,
              instances: [ new com.amazonaws.services.elasticloadbalancing.model.Instance( instanceId ) ]
          ) ).with {
            print( "Instance ${instanceStates?.getAt( 0 )?.instanceId} state: ${instanceStates?.getAt( 0 )?.state}" )
          }

          String instanceUrl = "http://${instancePublicIp}:9999/"
          print( "Accessing instance ${instanceUrl}" )
          String instanceResponse = new URL( instanceUrl ).
              getText( connectTimeout: 10000, readTimeout: 10000, useCaches: false, allowUserInteraction: false )
          print( "Got instance response: ${instanceResponse}" )
          assertThat( 'Hello' == instanceResponse, "Expected instance response Hello, but was: ${instanceResponse}" )

          String balancerUrl = "https://${balancerHost}:9999/"
          print( "Accessing instance via load balancer ${balancerUrl}" )
          String balancerResponse = new URL( balancerUrl ).openConnection( ).with { HttpsURLConnection urlConnection ->
            SSLContext context = SSLContext.getInstance( 'TLS' )
            context.init( null, [
              new X509TrustManager() {
                @Override void checkClientTrusted( X509Certificate[] x509Certificates, String s) throws CertificateException {
                }
                @Override void checkServerTrusted( X509Certificate[] x509Certificates, String s) throws CertificateException {
                  assertThat( cert.equals( x509Certificates[0] ), "Unexpected server certificate: ${x509Certificates[0]}" )
                }
                @Override X509Certificate[] getAcceptedIssuers() {
                  return new X509Certificate[0]
                }
              }
            ] as TrustManager[], null )
            urlConnection.setSSLSocketFactory( context.getSocketFactory( ) )
            urlConnection.setHostnameVerifier( { String s, SSLSession sslSession -> true } as HostnameVerifier )
            urlConnection.setConnectTimeout( 10000 )
            urlConnection.setReadTimeout( 10000 )
            urlConnection.setUseCaches( false )
            urlConnection.setAllowUserInteraction( false )
            urlConnection.getInputStream( )
          }.getText( )
          print( "Got balancer response: ${balancerResponse}" )
          assertThat( 'Hello' == balancerResponse, "Expected balancer response Hello, but was: ${balancerResponse}" )
        } else {
          print( "Skipping running instance test" )
        }

        void
      }

      print( "Test complete" )
    } finally {
      // Attempt to clean up anything we created
      cleanupTasks.reverseEach { Runnable cleanupTask ->
        try {
          cleanupTask.run()
        } catch ( Exception e ) {
          e.printStackTrace()
        }
      }
    }
  }
}
